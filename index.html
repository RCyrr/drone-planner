<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Drone Planner – GitHub Pages Optimiert</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<style>
body { margin:0; font-family:sans-serif; display:flex; height:100vh; }
#sidebar { width:360px; background:#fafafa; padding:1rem; overflow-y:auto; border-right:1px solid #ddd; }
#map { flex-grow:1; }
h3{margin-top:1rem;}
.output{background:#efefef; padding:.5rem; border-radius:8px; margin-top:.5rem;}
label{display:block; margin-top:.5rem;}
input, select{width:100%; padding:.3rem; margin-top:.2rem;}
button{margin-top:.5rem; padding:.5rem 1rem;}
.small{font-size:.9rem; color:#666}
.warning{color:#a00; font-weight:bold}
</style>
</head>
<body>
<div id="sidebar">
<h2>Drone Planner</h2>
<h3>1. Bild / Drohne</h3>
<input type="file" id="imageInput" accept="image/jpeg" />
<label>Drohne:</label>
<select id="droneSelect">
<option value="" disabled selected>Drohne wählen...</option>
<option value="DJI Mini 4 Pro">DJI Mini 4 Pro</option>
<option value="DJI Air 3">DJI Air 3</option>
<option value="DJI Mavic 3E">DJI Mavic 3E</option>
<option value="DJI Mavic 4E">DJI Mavic 4E</option>
<option value="DJI Mini 3 Pro">DJI Mini 3 Pro</option>
<option value="DJI Matrice 300 RTK">DJI Matrice 300 RTK</option>
<option value="DJI Phantom 4 RTK">DJI Phantom 4 RTK</option>
<option value="DJI Matrice 350 RTK">DJI Matrice 350 RTK</option>
<option value="custom">Custom Drone...</option>
</select>
<label>Brennweite [mm]:</label>
<input type="number" id="focalLength" placeholder="Wird automatisch gesetzt" />
<label>Pixelgröße [µm]:</label>
<input type="number" id="pixelSize" placeholder="Wird automatisch gesetzt" />
<div id="exifOutput" class="output"></div>
<div id="droneNote" class="small"></div>
<h3>2. Flugplanung</h3>
<p>Polygon zeichnen:</p>
<button id="drawPolygonBtn">Polygon zeichnen</button>
<button id="clearPolygonBtn">Polygon löschen</button>
<label>Flugrichtung [° 0=Nord, 90=Ost]:</label>
<input type="number" id="flightDirection" value="0" min="0" max="359" />
<label>GSD [cm/pixel]:</label>
<input type="number" id="gsd" value="2" min="0.1" step="0.1" />
<label>Flughöhe [m]:</label>
<input type="number" id="height" value="50" min="1" step="1" />
<label>Längsüberlappung [%]:</label>
<input type="number" id="frontlap" value="70" min="0" max="99" />
<label>Querüberlappung [%]:</label>
<input type="number" id="sidelap" value="60" min="0" max="99" />
<button id="calcStrips" disabled>Flugstreifen berechnen</button>
<div id="stripOutput" class="output"></div>
</div>
<div id="map"></div>

<!-- Bibliotheken -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exifr/dist/lite.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>

<script>
// Expanded drone database with EXIF model tags (modelTag)
const DRONE_DATABASE = {
  "DJI Mini 4 Pro":{modelTag:'FC8482',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:2268},
  "DJI Air 3":{modelTag:'FC8282',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:2268},
  "DJI Mavic 3E":{modelTag:'M3E',pixelSize_um:3.3,focalLength_mm:12.3,sensorWidth_px:5280,sensorHeight_px:3956},
  "DJI Mavic 4E":{modelTag:'M4E',pixelSize_um:3.3,focalLength_mm:12.3,sensorWidth_px:5280,sensorHeight_px:3956},
  "DJI Mini 3 Pro":{modelTag:'FC3582',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:3024},
  "DJI Matrice 300 RTK":{modelTag:'M300',pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648},
  "DJI Phantom 4 RTK":{modelTag:'FC6310R',pixelSize_um:2.4,focalLength_mm:8.8,sensorWidth_px:5472,sensorHeight_px:3648},
  "DJI Matrice 350 RTK":{modelTag:'M350',pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648}
};

const map = L.map('map').setView([48.137,11.575],13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
const drawnItems = new L.FeatureGroup().addTo(map);
map.addLayer(drawnItems);
const drawControl = new L.Control.Draw({draw:{polygon:{allowIntersection:false},polyline:false,rectangle:false,circle:false,marker:false,circlemarker:false},edit:{featureGroup:drawnItems}});
map.addControl(drawControl);
let polygon=null;

// LayerGroups für Streifen & Fotos
const layerStrips = L.layerGroup().addTo(map);
const layerPhotos = L.layerGroup().addTo(map);
const overlays = { "Streifen": layerStrips, "Fotopunkte": layerPhotos };
L.control.layers({}, overlays, { collapsed:false }).addTo(map);

// UI-Elemente
const drawBtn = document.getElementById('drawPolygonBtn');
const clearBtn = document.getElementById('clearPolygonBtn');
const imageInput = document.getElementById('imageInput');
const exifBox = document.getElementById('exifOutput');
const droneSelect = document.getElementById('droneSelect');
const focalInput = document.getElementById('focalLength');
const pixelInput = document.getElementById('pixelSize');
const droneNote = document.getElementById('droneNote');
const calcBtn = document.getElementById('calcStrips');
const gsdInput = document.getElementById('gsd');
const heightInput = document.getElementById('height');
const frontlapInput = document.getElementById('frontlap');
const sidelapInput = document.getElementById('sidelap');
const directionInput = document.getElementById('flightDirection');
const stripOutput = document.getElementById('stripOutput');

// init state
pixelInput.readOnly = true;
focalInput.readOnly = false; // allow override even for DB entries
calcBtn.disabled = true;

function setDroneValues(name){
  if(!name || name==='') return;
  if(name==='custom'){
    // allow manual entry
    pixelInput.readOnly = false;
    focalInput.readOnly = false;
    pixelInput.value = '';
    focalInput.value = '';
    droneNote.innerText = 'Custom Drone: bitte Brennweite und Pixelgröße eingeben (Pixelgröße in µm)';
    return;
  }
  const d = DRONE_DATABASE[name];
  if(d){
    pixelInput.value = d.pixelSize_um;
    pixelInput.readOnly = true;
    focalInput.value = d.focalLength_mm;
    focalInput.readOnly = false; // user still allowed to override
    droneNote.innerText = `Aus Drohnendatenbank geladen: modelTag=${d.modelTag}`;
  }
}

// check readiness to enable calc button
function checkReady(){
  const droneName = droneSelect.value;
  if(!droneName) { calcBtn.disabled=true; return; }
  // require focal and pixel
  const focal = parseFloat(focalInput.value);
  const pixel = parseFloat(pixelInput.value);
  const gsd = parseFloat(gsdInput.value);
  const H = parseFloat(heightInput.value);
  const hasGsdOrH = (!isNaN(gsd) && gsd>0) || (!isNaN(H) && H>0);
  const hasFocal = !isNaN(focal) && focal>0;
  const hasPixel = !isNaN(pixel) && pixel>0;
  const hasPoly = polygon instanceof L.Polygon;
  if(hasFocal && hasPixel && hasGsdOrH && hasPoly){ calcBtn.disabled=false; } else { calcBtn.disabled=true; }
}

// event hookup
droneSelect.addEventListener('change', ()=>{
  setDroneValues(droneSelect.value);
  checkReady();
});

// EXIF handling with user choice popup (Method B)
imageInput.addEventListener('change', async ()=>{
  const file = imageInput.files[0]; if(!file) return;
  const exif = await exifr.parse(file);
  exifBox.innerHTML = '';
  if(!exif){ exifBox.innerText = 'Keine EXIF-Daten gefunden.'; return; }

  const exifModel = exif.Model || exif.Make || null; // try Model first then Make
  const exifFocal = exif.FocalLength || exif.FocalLengthIn35mmFormat || null;
  const exifW = exif.ExifImageWidth || exif.PixelXDimension || null;
  const exifH = exif.ExifImageHeight || exif.PixelYDimension || null;

  exifBox.innerHTML = `EXIF: Model=${exifModel||'-'}, Focal=${exifFocal||'-'}mm, Size=${exifW||'-'}x${exifH||'-'}`;

  // try match drone by modelTag
  let matchedName = null;
  for(const name in DRONE_DATABASE){ const d=DRONE_DATABASE[name]; if(d.modelTag && exifModel && exifModel.toString().includes(d.modelTag)){ matchedName = name; break; } }

  // if matched and a drone is selected and matches, offer choice
  if(matchedName){
    // if selected drone matches matchedName, compare
    if(droneSelect.value && droneSelect.value!=='' && droneSelect.value!== 'custom'){
      const selected = droneSelect.value;
      if(selected===matchedName && exifFocal){
        // compare
        const dbF = DRONE_DATABASE[selected].focalLength_mm;
        const diff = Math.abs(exifFocal - dbF)/dbF;
        let msg = `EXIF Brennweite ${exifFocal}mm gefunden für Model ${exifModel}.
Datenbank: ${dbF}mm.`;
        if(diff>0.1) msg += "\n\nAbweichung >10% — möchtest du EXIF-Wert verwenden? OK = EXIF, Abbrechen = Drohnendatenbank";
        else msg += "\n\nOK = EXIF, Abbrechen = Drohnendatenbank";
        const useExif = window.confirm(msg);
        if(useExif){ focalInput.value = exifFocal; }
        else { focalInput.value = dbF; }
      }
    } else {
      // if no selected drone, pre-select matchedName to help user
      droneSelect.value = matchedName;
      setDroneValues(matchedName);
      // if exif focal exists, ask user which to use
      if(exifFocal){
        const dbF = DRONE_DATABASE[matchedName].focalLength_mm;
        const diff = Math.abs(exifFocal - dbF)/dbF;
        let msg = `EXIF Brennweite ${exifFocal}mm gefunden für Model ${exifModel}.
Datenbank: ${dbF}mm.`;
        if(diff>0.1) msg += "\n\nAbweichung >10% — möchtest du EXIF-Wert verwenden? OK = EXIF, Abbrechen = Drohnendatenbank";
        else msg += "\n\nOK = EXIF, Abbrechen = Drohnendatenbank";
        const useExif = window.confirm(msg);
        if(useExif){ focalInput.value = exifFocal; }
      }
    }
  } else {
    // not matched: if user wants to use EXIF focal for custom or unknown, ask
    if(exifFocal){
      const useExif = window.confirm(`EXIF Brennweite ${exifFocal}mm gefunden (Model=${exifModel}). OK = Verwenden, Abbrechen = nicht übernehmen`);
      if(useExif){ focalInput.value = exifFocal; }
    }
    // if image size present and drone is custom, populate sensor pixels
    if(exifW && exifH && droneSelect.value==='custom'){
      // set sensor px as EXIF image size if user chooses
      pixelInput.value = pixelInput.value || '';
      // if empty, set sensor sizes implicitly by using image size for sensor px? We assume sensor px = image px for custom workflow
      if(!pixelInput.value) pixelInput.value = '';
      exifBox.innerHTML += '<br>Hinweis: Bildgröße in EXIF erkannt — falls Sensordaten fehlen, bitte Pixelgröße manuell eingeben.';
    }
  }
  checkReady();
});

// set defaults when user selects drone
setDroneValues(droneSelect.value);

// GSD <-> Height coupling
gsdInput.addEventListener('input', ()=>{
  const pixelSize_m = (parseFloat(pixelInput.value) || 0)*1e-6;
  const focal_m = (parseFloat(focalInput.value) || 0)*1e-3;
  const gsd_cm = parseFloat(gsdInput.value);
  if(!pixelSize_m || !focal_m || isNaN(gsd_cm)) return;
  const gsd_m = gsd_cm/100;
  const H = gsd_m * focal_m / pixelSize_m;
  if(!isNaN(H)) heightInput.value = H.toFixed(2);
  checkReady();
});
heightInput.addEventListener('input', ()=>{
  const pixelSize_m = (parseFloat(pixelInput.value) || 0)*1e-6;
  const focal_m = (parseFloat(focalInput.value) || 0)*1e-3;
  const H = parseFloat(heightInput.value);
  if(!pixelSize_m || !focal_m || isNaN(H)) return;
  const gsd_cm = H * pixelSize_m / focal_m * 100;
  if(!isNaN(gsd_cm)) gsdInput.value = gsd_cm.toFixed(2);
  checkReady();
});

// when focal or pixel manually edited, re-check readiness
focalInput.addEventListener('input', checkReady);
pixelInput.addEventListener('input', checkReady);
frontlapInput.addEventListener('input', checkReady);
sidelapInput.addEventListener('input', checkReady);
directionInput.addEventListener('input', checkReady);

// Polygon drawing
drawBtn.onclick = ()=>{ new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable(); };
clearBtn.onclick = ()=>{ drawnItems.clearLayers(); polygon=null; clearStrips(); checkReady(); };
map.on(L.Draw.Event.CREATED, function(e){
  if(e.layer instanceof L.Polygon){
    drawnItems.clearLayers();
    polygon = e.layer;
    drawnItems.addLayer(polygon);
  } else {
    polygon = null;
  }
  checkReady();
});

// Flugstreifen + Foto-Punkte (wie zuvor, unchanged)
function clearStrips(){ layerStrips.clearLayers(); layerPhotos.clearLayers(); }

calcBtn.onclick = () => {
  if(!polygon) return;
  clearStrips();
  const droneName = droneSelect.value;
  const drone = DRONE_DATABASE[droneName];
  const pixelSize_m=(parseFloat(pixelInput.value)|| (drone?drone.pixelSize_um:0))*1e-6;
  const focal_m=(parseFloat(focalInput.value)|| (drone?drone.focalLength_mm:0))*1e-3;
  const imgW = drone?drone.sensorWidth_px: (parseInt(exifBox.dataset.imgw)||0);
  const imgH = drone?drone.sensorHeight_px: (parseInt(exifBox.dataset.imgh)||0);
  const H = parseFloat(heightInput.value);
  const frontlap = parseFloat(frontlapInput.value)/100;
  const sidelap = parseFloat(sidelapInput.value)/100;
  const dir = parseFloat(directionInput.value)%360;

  const sensorW_m = imgW*pixelSize_m;
  const sensorH_m = imgH*pixelSize_m;
  const footprintX = H*sensorW_m/focal_m; // image width on ground [m]
  const footprintY = H*sensorH_m/focal_m; // image height on ground [m]
  stripOutput.innerHTML = `Footprint: ${footprintX.toFixed(2)} m x ${footprintY.toFixed(2)} m`;

  // prepare polygon (GeoJSON)
  const poly = turf.polygon(polygon.toGeoJSON().geometry.coordinates);
  const centroid = turf.centroid(poly);
  const rotatedPoly = turf.transformRotate(poly, -dir, { pivot: centroid });
  const bbox = turf.bbox(rotatedPoly); // [minX,minY,maxX,maxY] in lon/lat

  // spacing in meters
  const stripSpacing = footprintX*(1-sidelap);
  const photoSpacing = footprintY*(1-frontlap);

  const minX = bbox[0], maxX = bbox[2];
  const bboxCenter = [(bbox[0]+bbox[2])/2, (bbox[1]+bbox[3])/2];
  const leftPoint = turf.point([minX, bboxCenter[1]]);
  const rightPoint = turf.point([maxX, bboxCenter[1]]);
  const totalWidth_km = turf.distance(leftPoint, rightPoint, {units:'kilometers'});
  const totalWidth_m = totalWidth_km*1000;
  const numStrips = Math.ceil((totalWidth_m + stripSpacing*4) / stripSpacing);
  const startPoint = turf.destination(leftPoint, (-2*stripSpacing)/1000, 90, {units:'kilometers'});

  for(let i=0;i<numStrips;i++){
    const offset_m = i*stripSpacing;
    const offsetPoint = turf.destination(startPoint, offset_m/1000, 90, {units:'kilometers'});
    const top = turf.destination(offsetPoint, 20000/1000, 0, {units:'kilometers'});
    const bottom = turf.destination(offsetPoint, 20000/1000, 180, {units:'kilometers'});
    const line = turf.lineString([bottom.geometry.coordinates, top.geometry.coordinates]);

    const split = turf.lineSplit(line, rotatedPoly);
    split.features.forEach(seg=>{
      const segMid = turf.midpoint(turf.point(seg.geometry.coordinates[0]), turf.point(seg.geometry.coordinates[seg.geometry.coordinates.length-1]));
      if(turf.booleanPointInPolygon(segMid, rotatedPoly)){
        const segBack = turf.transformRotate(seg, dir, { pivot: centroid });
        const latlngs = segBack.geometry.coordinates.map(c=>[c[1], c[0]]);
        L.polyline(latlngs, {color:'green'}).addTo(layerStrips);

        const segLength_km = turf.length(seg, {units:'kilometers'});
        const segLength_m = segLength_km*1000;
        if(segLength_m < 1) return;
        const stepCount = Math.floor(segLength_m / photoSpacing);
        for(let s=0;s<=stepCount;s++){
          const dist_km = (s * photoSpacing)/1000;
          const ptOnSeg = turf.along(seg, dist_km, {units:'kilometers'});
          const ptBack = turf.transformRotate(ptOnSeg, dir, { pivot: centroid });
          const coords = ptBack.geometry.coordinates; // [lng,lat]
          if(turf.booleanPointInPolygon(ptBack, poly)){
            L.circleMarker([coords[1], coords[0]], {radius:3, color:'red'}).addTo(layerPhotos);
          }
        }
      }
    });
  }
};

// initial check
checkReady();
</script>
</body>
</html>
