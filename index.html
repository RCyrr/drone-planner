<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Drone Planner – GitHub Pages Optimiert</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<style>
body { margin:0; font-family:sans-serif; display:flex; height:100vh; }
#sidebar { width:360px; background:#fafafa; padding:1rem; overflow-y:auto; border-right:1px solid #ddd; }
#map { flex-grow:1; }
h3{margin-top:1rem;}
.output{background:#efefef; padding:.5rem; border-radius:8px; margin-top:.5rem;}
label{display:block; margin-top:.5rem;}
input, select{width:100%; padding:.3rem; margin-top:.2rem;}
button{margin-top:.5rem; padding:.5rem 1rem;}
.small{font-size:.9rem; color:#666}
.warning{color:#a00; font-weight:bold}
#langToggle { float:right; margin-top:0; padding:.3rem .6rem; font-size:.9rem; }
#summary table { width:100%; font-size:.9rem; margin-top:.5rem; border-collapse:collapse; }
#summary td { padding:.2rem; border-bottom:1px solid #ddd; }
#summary td:first-child { font-weight:bold; }
.export-btn { margin-right:.5rem; margin-top:.5rem; }

/* Mobile responsive */
@media (max-width: 768px) {
  body { flex-direction:column; }
  #sidebar { width:100%; height:50vh; position:relative; }
  #map { height:50vh; }
  button, input, select { font-size:1rem; padding:.6rem; }
  #langToggle { position:absolute; top:1rem; right:1rem; }
}
</style>
</head>
<body>
<div id="sidebar">
  <h2>Drone Planner <button id="langToggle">EN</button></h2>
  <h3 id="section1">1. Bild / Drohne</h3>
  <input type="file" id="imageInput" accept="image/jpeg" />
  <label id="labelDrone">Drohne:</label>
  <select id="droneSelect">
    <option value="" disabled selected>Drohne wählen...</option>
    <option value="DJI Mini 4 Pro">DJI Mini 4 Pro</option>
    <option value="DJI Air 3">DJI Air 3</option>
    <option value="DJI Mavic 3E">DJI Mavic 3E</option>
    <option value="DJI Mavic 4E">DJI Mavic 4E</option>
    <option value="DJI Mini 3 Pro">DJI Mini 3 Pro</option>
    <option value="DJI Matrice 300 RTK">DJI Matrice 300 RTK</option>
    <option value="DJI Phantom 4 RTK">DJI Phantom 4 RTK</option>
    <option value="DJI Matrice 350 RTK">DJI Matrice 350 RTK</option>
    <option value="custom">Custom Drone...</option>
  </select>
  <label id="labelFocal">Brennweite [mm]:</label>
  <input type="number" id="focalLength" placeholder="Wird automatisch gesetzt" />
  <label id="labelPixel">Pixelgröße [µm]:</label>
  <input type="number" id="pixelSize" placeholder="Wird automatisch gesetzt" />
  <div id="exifOutput" class="output"></div>
  <div id="droneNote" class="small"></div>
  <h3 id="section2">2. Flugplanung</h3>
  <p id="polygonDraw">Polygon zeichnen:</p>
  <button id="drawPolygonBtn">Polygon zeichnen</button>
  <button id="clearPolygonBtn">Polygon löschen</button>
  <label id="labelShapefile">Shapefile importieren:</label>
  <input type="file" id="shapefileInput" accept=".shp" />
  <label id="labelDirection">Flugrichtung [° 0=Nord, 90=Ost]:</label>
  <input type="number" id="flightDirection" value="0" min="0" max="359" />
  <label id="labelGsd">GSD [cm/pixel]:</label>
  <input type="number" id="gsd" value="2" min="0.1" step="0.1" />
  <label id="labelHeight">Flughöhe [m]:</label>
  <input type="number" id="height" value="50" min="1" step="1" />
  <label id="labelFrontlap">Längsüberlappung [%]:</label>
  <input type="number" id="frontlap" value="70" min="0" max="99" />
  <label id="labelSidelap">Querüberlappung [%]:</label>
  <input type="number" id="sidelap" value="60" min="0" max="99" />
  <button id="calcStrips" disabled>Flugstreifen berechnen</button>
  <div id="stripOutput" class="output"></div>
  <div id="summary" style="display:none;">
    <h3 id="summaryTitle">Zusammenfassung</h3>
    <div id="summaryWarning" class="warning"></div>
    <table id="summaryTable"></table>
    <button id="exportCsv" class="export-btn">CSV Export</button>
    <button id="exportJson" class="export-btn">JSON Export</button>
  </div>
  <div id="photoFilter" style="display:none; margin-top:1rem;">
    <h4>Fotopunkte filtern:</h4>
    <label>Anzahl Punkte am Anfang/Ende behalten:</label>
    <input type="number" id="filterCount" value="3" min="0" max="50" />
    <button id="applyFilterBtn">Filter anwenden</button>
    <button id="resetFilterBtn">Filter zurücksetzen</button>
  </div>
  <button id="exportKmlBtn" class="export-btn" style="display:none;">KML Export</button>
  <div id="loadingElevation" style="display:none; margin-top:1rem; font-weight:bold;">Loading elevation data...</div>
</div>
<div id="map"></div>

<!-- Bibliotheken -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exifr/dist/lite.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/shapefile@0.6.6/dist/shapefile.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
  if (!document.getElementById("loadingElevation")) {
    const loadingDiv = document.createElement("div");
    loadingDiv.id = "loadingElevation";
    loadingDiv.style.display = "none";
    loadingDiv.style.marginTop = "1rem";
    loadingDiv.style.fontWeight = "bold";
    loadingDiv.textContent = "Loading elevation data...";
    // Insert at end of sidebar (before map)
    const sidebar = document.getElementById("sidebar");
    if (sidebar) sidebar.appendChild(loadingDiv);
    else document.body.appendChild(loadingDiv);
    console.log("Inserted loadingElevation div programmatically.");
  }
});
// Expanded drone database with EXIF model tags (modelTag)
const DRONE_DATABASE = {
  "DJI Mini 4 Pro":{modelTag:'FC8482',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:2268},
  "DJI Air 3":{modelTag:'FC8282',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:2268},
  "DJI Mavic 3E":{modelTag:'M3E',pixelSize_um:3.3,focalLength_mm:12.3,sensorWidth_px:5280,sensorHeight_px:3956},
  "DJI Mavic 4E":{modelTag:'M4E',pixelSize_um:3.3,focalLength_mm:12.3,sensorWidth_px:5280,sensorHeight_px:3956},
  "DJI Mini 3 Pro":{modelTag:'FC3582',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:3024},
  "DJI Matrice 300 RTK":{modelTag:'M300',pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648},
  "DJI Phantom 4 RTK":{modelTag:'FC6310R',pixelSize_um:2.4,focalLength_mm:8.8,sensorWidth_px:5472,sensorHeight_px:3648},
  "DJI Matrice 350 RTK":{modelTag:'M350',pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648}
};

const TRANSLATIONS = {
  de: {
    title: 'Drone Planner – GitHub Pages Optimiert',
    appTitle: 'Drone Planner',
    section1: '1. Bild / Drohne',
    section2: '2. Flugplanung',
    labelDrone: 'Drohne:',
    dronePlaceholder: 'Drohne wählen...',
    labelFocal: 'Brennweite [mm]:',
    focalPlaceholder: 'Wird automatisch gesetzt',
    labelPixel: 'Pixelgröße [µm]:',
    pixelPlaceholder: 'Wird automatisch gesetzt',
    polygonDraw: 'Polygon zeichnen:',
    drawBtn: 'Polygon zeichnen',
    clearBtn: 'Polygon löschen',
    labelShapefile: 'Shapefile importieren:',
    labelDirection: 'Flugrichtung [° 0=Nord, 90=Ost]:',
    labelGsd: 'GSD [cm/pixel]:',
    labelHeight: 'Flughöhe [m]:',
    labelFrontlap: 'Längsüberlappung [%]:',
    labelSidelap: 'Querüberlappung [%]:',
    calcBtn: 'Flugstreifen berechnen',
    exifNone: 'Keine EXIF-Daten gefunden.',
    exifFormat: 'EXIF: Model={model}, Focal={focal}mm, Size={width}x{height}',
    droneCustomNote: 'Custom Drone: bitte Brennweite und Pixelgröße eingeben (Pixelgröße in µm)',
    droneDbNotePrefix: 'Aus Drohnendatenbank geladen: modelTag=',
    summaryTitle: 'Zusammenfassung',
    summaryArea: 'Fläche',
    summaryStrips: 'Anzahl Streifen',
    summaryPhotos: 'Anzahl Fotos',
    summaryLength: 'Gesamtlänge',
    summaryTime: 'Geschätzte Flugzeit',
    exportCsv: 'CSV Export',
    exportJson: 'JSON Export',
    photoFilterTitle: 'Fotopunkte filtern:',
    photoFilterLabel: 'Anzahl Punkte am Anfang/Ende behalten:',
    applyFilter: 'Filter anwenden',
    resetFilter: 'Filter zurücksetzen',
    exportKml: 'KML Export'
  },
  en: {
    title: 'Drone Planner – GitHub Pages Optimized',
    appTitle: 'Drone Planner',
    section1: '1. Image / Drone',
    section2: '2. Flight Planning',
    labelDrone: 'Drone:',
    dronePlaceholder: 'Select drone...',
    labelFocal: 'Focal Length [mm]:',
    focalPlaceholder: 'Auto-filled',
    labelPixel: 'Pixel Size [µm]:',
    pixelPlaceholder: 'Auto-filled',
    polygonDraw: 'Draw Polygon:',
    drawBtn: 'Draw Polygon',
    clearBtn: 'Clear Polygon',
    labelShapefile: 'Import Shapefile:',
    labelDirection: 'Flight Direction [° 0=North, 90=East]:',
    labelGsd: 'GSD [cm/pixel]:',
    labelHeight: 'Flight Height [m]:',
    labelFrontlap: 'Front Overlap [%]:',
    labelSidelap: 'Side Overlap [%]:',
    calcBtn: 'Calculate Flight Strips',
    exifNone: 'No EXIF data found.',
    exifFormat: 'EXIF: Model={model}, Focal={focal}mm, Size={width}x{height}',
    droneCustomNote: 'Custom Drone: please enter focal length and pixel size (pixel size in µm)',
    droneDbNotePrefix: 'Loaded from drone database: modelTag=',
    summaryTitle: 'Summary',
    summaryArea: 'Area',
    summaryStrips: 'Number of Strips',
    summaryPhotos: 'Number of Photos',
    summaryLength: 'Total Length',
    summaryTime: 'Estimated Flight Time',
    exportCsv: 'Export CSV',
    exportJson: 'Export JSON',
    photoFilterTitle: 'Filter Photo Points:',
    photoFilterLabel: 'Points to keep at start/end:',
    applyFilter: 'Apply Filter',
    resetFilter: 'Reset Filter',
    exportKml: 'Export KML'
  }
};

let currentLang = localStorage.getItem('dronePlannerLang') || 'de';
function t(key) { return TRANSLATIONS[currentLang][key] || key; }
function setLanguage(lang) {
  currentLang = lang;
  localStorage.setItem('dronePlannerLang', lang);
  document.documentElement.lang = lang;
  document.getElementById('langToggle').textContent = lang === 'de' ? 'EN' : 'DE';
  // Update all UI texts
  document.getElementById('section1').textContent = t('section1');
  document.getElementById('section2').textContent = t('section2');
  document.getElementById('labelDrone').textContent = t('labelDrone');
  document.getElementById('droneSelect').options[0].text = t('dronePlaceholder');
  document.getElementById('labelFocal').textContent = t('labelFocal');
  document.getElementById('focalLength').placeholder = t('focalPlaceholder');
  document.getElementById('labelPixel').textContent = t('labelPixel');
  document.getElementById('pixelSize').placeholder = t('pixelPlaceholder');
  document.getElementById('polygonDraw').textContent = t('polygonDraw');
  document.getElementById('drawPolygonBtn').textContent = t('drawBtn');
  document.getElementById('clearPolygonBtn').textContent = t('clearBtn');
  document.getElementById('labelDirection').textContent = t('labelDirection');
  document.getElementById('labelGsd').textContent = t('labelGsd');
  document.getElementById('labelHeight').textContent = t('labelHeight');
  document.getElementById('labelFrontlap').textContent = t('labelFrontlap');
  document.getElementById('labelSidelap').textContent = t('labelSidelap');
  document.getElementById('calcStrips').textContent = t('calcBtn');
  document.getElementById('summaryTitle').textContent = t('summaryTitle');
  document.getElementById('exportCsv').textContent = t('exportCsv');
  document.getElementById('exportJson').textContent = t('exportJson');
  // Update photo filter UI texts
  const photoFilterTitle = photoFilterDiv.querySelector('h4');
  if (photoFilterTitle) photoFilterTitle.textContent = t('photoFilterTitle');
  const filterLabel = document.querySelector('label[for="filterCount"]');
  if (filterLabel) filterLabel.textContent = t('photoFilterLabel');
  document.getElementById('applyFilterBtn').textContent = t('applyFilter');
  document.getElementById('resetFilterBtn').textContent = t('resetFilter');
  document.getElementById('exportKmlBtn').textContent = t('exportKml');
}

const map = L.map('map').setView([48.137,11.575],13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
const drawnItems = new L.FeatureGroup().addTo(map);
map.addLayer(drawnItems);
const drawControl = new L.Control.Draw({draw:{polygon:{allowIntersection:false},polyline:false,rectangle:false,circle:false,marker:false,circlemarker:false},edit:{featureGroup:drawnItems}});
map.addControl(drawControl);
let polygon=null;

// LayerGroups für Streifen & Fotos
const layerStrips = L.layerGroup().addTo(map);
const layerPhotos = L.layerGroup().addTo(map);
const overlays = { "Streifen": layerStrips, "Fotopunkte": layerPhotos };
L.control.layers({}, overlays, { collapsed:false }).addTo(map);

// UI-Elemente
const drawBtn = document.getElementById('drawPolygonBtn');
const clearBtn = document.getElementById('clearPolygonBtn');
const imageInput = document.getElementById('imageInput');
const exifBox = document.getElementById('exifOutput');
const droneSelect = document.getElementById('droneSelect');
const focalInput = document.getElementById('focalLength');
const pixelInput = document.getElementById('pixelSize');
const droneNote = document.getElementById('droneNote');
const calcBtn = document.getElementById('calcStrips');
const gsdInput = document.getElementById('gsd');
const heightInput = document.getElementById('height');
const frontlapInput = document.getElementById('frontlap');
const sidelapInput = document.getElementById('sidelap');
const directionInput = document.getElementById('flightDirection');
const stripOutput = document.getElementById('stripOutput');
const summaryDiv = document.getElementById('summary');
const summaryTable = document.getElementById('summaryTable');
const exportCsvBtn = document.getElementById('exportCsv');
const exportJsonBtn = document.getElementById('exportJson');
const shapefileInput = document.getElementById('shapefileInput');
const photoFilterDiv = document.getElementById('photoFilter');
const filterCountInput = document.getElementById('filterCount');
const applyFilterBtn = document.getElementById('applyFilterBtn');
const resetFilterBtn = document.getElementById('resetFilterBtn');
const exportKmlBtn = document.getElementById('exportKmlBtn');

// init state
pixelInput.readOnly = true;
focalInput.readOnly = false; // allow override even for DB entries
calcBtn.disabled = true;
setLanguage(currentLang);

// Format numbers with German decimal comma and fixed decimals
function formatNumberDE(num, decimals=2) {
  if (isNaN(num)) return '-';
  return num.toFixed(decimals).replace('.', ',');
}

function setDroneValues(name){
  if(!name || name==='') return;
  if(name==='custom'){
    // allow manual entry
    pixelInput.readOnly = false;
    focalInput.readOnly = false;
    pixelInput.value = '';
    focalInput.value = '';
    droneNote.innerText = t('droneCustomNote');
    return;
  }
  const d = DRONE_DATABASE[name];
  if(d){
    pixelInput.value = d.pixelSize_um;
    pixelInput.readOnly = true;
    focalInput.value = d.focalLength_mm;
    focalInput.readOnly = false; // user still allowed to override
    droneNote.innerText = t('droneDbNotePrefix') + d.modelTag;
  }
}

// check readiness to enable calc button
function checkReady(){
  const droneName = droneSelect.value;
  if(!droneName) { calcBtn.disabled=true; return; }
  // require focal and pixel
  const focal = parseFloat(focalInput.value);
  const pixel = parseFloat(pixelInput.value);
  const gsd = parseFloat(gsdInput.value);
  const H = parseFloat(heightInput.value);
  const hasGsdOrH = (!isNaN(gsd) && gsd>0) || (!isNaN(H) && H>0);
  const hasFocal = !isNaN(focal) && focal>0;
  const hasPixel = !isNaN(pixel) && pixel>0;
  const hasPoly = polygon instanceof L.Polygon;
  if(hasFocal && hasPixel && hasGsdOrH && hasPoly){ calcBtn.disabled=false; } else { calcBtn.disabled=true; }
}

// event hookup
droneSelect.addEventListener('change', ()=>{
  setDroneValues(droneSelect.value);
  checkReady();
});

// EXIF handling with user choice popup (Method B)
imageInput.addEventListener('change', async ()=>{
  const file = imageInput.files[0]; if(!file) return;
  const exif = await exifr.parse(file);
  exifBox.innerHTML = '';
  if(!exif){ exifBox.innerText = t('exifNone'); return; }

  const exifModel = exif.Model || exif.Make || null; // try Model first then Make
  const exifFocal = exif.FocalLength || exif.FocalLengthIn35mmFormat || null;
  const exifW = exif.ExifImageWidth || exif.PixelXDimension || null;
  const exifH = exif.ExifImageHeight || exif.PixelYDimension || null;

  exifBox.innerHTML = t('exifFormat')
    .replace('{model}', exifModel||'-')
    .replace('{focal}', exifFocal||'-')
    .replace('{width}', exifW||'-')
    .replace('{height}', exifH||'-');

  // try match drone by modelTag
  let matchedName = null;
  for(const name in DRONE_DATABASE){ const d=DRONE_DATABASE[name]; if(d.modelTag && exifModel && exifModel.toString().includes(d.modelTag)){ matchedName = name; break; } }

  // if matched and a drone is selected and matches, offer choice
  if(matchedName){
    // if selected drone matches matchedName, compare
    if(droneSelect.value && droneSelect.value!=='' && droneSelect.value!== 'custom'){
      const selected = droneSelect.value;
      if(selected===matchedName && exifFocal){
        // compare
        const dbF = DRONE_DATABASE[selected].focalLength_mm;
        const diff = Math.abs(exifFocal - dbF)/dbF;
        let msg = `EXIF Brennweite ${exifFocal}mm gefunden für Model ${exifModel}.
Datenbank: ${dbF}mm.`;
        if(diff>0.1) msg += "\n\nAbweichung >10% — möchtest du EXIF-Wert verwenden? OK = EXIF, Abbrechen = Drohnendatenbank";
        else msg += "\n\nOK = EXIF, Abbrechen = Drohnendatenbank";
        const useExif = window.confirm(msg);
        if(useExif){ focalInput.value = exifFocal; }
        else { focalInput.value = dbF; }
      }
    } else {
      // if no selected drone, pre-select matchedName to help user
      droneSelect.value = matchedName;
      setDroneValues(matchedName);
      // if exif focal exists, ask user which to use
      if(exifFocal){
        const dbF = DRONE_DATABASE[matchedName].focalLength_mm;
        const diff = Math.abs(exifFocal - dbF)/dbF;
        let msg = `EXIF Brennweite ${exifFocal}mm gefunden für Model ${exifModel}.
Datenbank: ${dbF}mm.`;
        if(diff>0.1) msg += "\n\nAbweichung >10% — möchtest du EXIF-Wert verwenden? OK = EXIF, Abbrechen = Drohnendatenbank";
        else msg += "\n\nOK = EXIF, Abbrechen = Drohnendatenbank";
        const useExif = window.confirm(msg);
        if(useExif){ focalInput.value = exifFocal; }
      }
    }
  } else {
    // not matched: if user wants to use EXIF focal for custom or unknown, ask
    if(exifFocal){
      const useExif = window.confirm(`EXIF Brennweite ${exifFocal}mm gefunden (Model=${exifModel}). OK = Verwenden, Abbrechen = nicht übernehmen`);
      if(useExif){ focalInput.value = exifFocal; }
    }
    // if image size present and drone is custom, populate sensor pixels
    if(exifW && exifH && droneSelect.value==='custom'){
      // set sensor px as EXIF image size if user chooses
      pixelInput.value = pixelInput.value || '';
      // if empty, set sensor sizes implicitly by using image size for sensor px? We assume sensor px = image px for custom workflow
      if(!pixelInput.value) pixelInput.value = '';
      exifBox.innerHTML += '<br>Hinweis: Bildgröße in EXIF erkannt — falls Sensordaten fehlen, bitte Pixelgröße manuell eingeben.';
    }
  }
  checkReady();
});

// set defaults when user selects drone
setDroneValues(droneSelect.value);

// GSD <-> Height coupling
gsdInput.addEventListener('input', ()=>{
  const pixelSize_m = (parseFloat(pixelInput.value) || 0)*1e-6;
  const focal_m = (parseFloat(focalInput.value) || 0)*1e-3;
  const gsd_cm = parseFloat(gsdInput.value);
  if(!pixelSize_m || !focal_m || isNaN(gsd_cm)) return;
  const gsd_m = gsd_cm/100;
  const H = gsd_m * focal_m / pixelSize_m;
  if(!isNaN(H)) heightInput.value = H.toFixed(2);
  checkReady();
});
heightInput.addEventListener('input', ()=>{
  const pixelSize_m = (parseFloat(pixelInput.value) || 0)*1e-6;
  const focal_m = (parseFloat(focalInput.value) || 0)*1e-3;
  const H = parseFloat(heightInput.value);
  if(!pixelSize_m || !focal_m || isNaN(H)) return;
  const gsd_cm = H * pixelSize_m / focal_m * 100;
  if(!isNaN(gsd_cm)) gsdInput.value = gsd_cm.toFixed(2);
  checkReady();
});

// when focal or pixel manually edited, re-check readiness
focalInput.addEventListener('input', checkReady);
pixelInput.addEventListener('input', checkReady);
frontlapInput.addEventListener('input', checkReady);
sidelapInput.addEventListener('input', checkReady);
directionInput.addEventListener('input', checkReady);

// Shapefile import
shapefileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const reader = new FileReader();
    reader.onload = async (event) => {
      const arrayBuffer = event.target.result;
      const geojson = await shapefile.read(arrayBuffer);
      
      if (geojson.features && geojson.features.length > 0) {
        // Clear existing polygon
        drawnItems.clearLayers();
        polygon = null;
        clearStrips();
        
        // Find first polygon feature
        const polygonFeature = geojson.features.find(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        );
        
        if (polygonFeature) {
          // Convert to Leaflet layer
          const layer = L.geoJSON(polygonFeature, {
            style: { color: 'blue', weight: 2 }
          });
          
          // Get the polygon geometry
          const coords = polygonFeature.geometry.type === 'Polygon'
            ? polygonFeature.geometry.coordinates
            : polygonFeature.geometry.coordinates[0];
          
          // Create Leaflet polygon
          const latlngs = coords[0].map(coord => [coord[1], coord[0]]);
          polygon = L.polygon(latlngs, { color: 'blue', weight: 2 });
          drawnItems.addLayer(polygon);
          
          // Center map on polygon
          map.fitBounds(polygon.getBounds());
          
          stripOutput.innerHTML = `Shapefile imported: ${polygonFeature.geometry.type}`;
          checkReady();
        } else {
          stripOutput.innerHTML = 'No polygon found in shapefile';
        }
      } else {
        stripOutput.innerHTML = 'Invalid shapefile or no features found';
      }
    };
    reader.readAsArrayBuffer(file);
  } catch (error) {
    stripOutput.innerHTML = `Error loading shapefile: ${error.message}`;
  }
});

// Polygon drawing
drawBtn.onclick = ()=>{ new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable(); };
clearBtn.onclick = ()=>{ drawnItems.clearLayers(); polygon=null; clearStrips(); checkReady(); };
map.on(L.Draw.Event.CREATED, function(e){
  if(e.layer instanceof L.Polygon){
    drawnItems.clearLayers();
    polygon = e.layer;
    drawnItems.addLayer(polygon);
  } else {
    polygon = null;
  }
  checkReady();
});

// Flugstreifen + Foto-Punkte (wie zuvor, unchanged)
function clearStrips(){ layerStrips.clearLayers(); layerPhotos.clearLayers(); }

let summaryStats = {};

calcBtn.onclick = () => {
  if(!polygon) return;
  clearStrips();
  const droneName = droneSelect.value;
  const drone = DRONE_DATABASE[droneName];
  const pixelSize_m=(parseFloat(pixelInput.value)|| (drone?drone.pixelSize_um:0))*1e-6;
  const focal_m=(parseFloat(focalInput.value)|| (drone?drone.focalLength_mm:0))*1e-3;
  const imgW = drone?drone.sensorWidth_px: (parseInt(exifBox.dataset.imgw)||0);
  const imgH = drone?drone.sensorHeight_px: (parseInt(exifBox.dataset.imgh)||0);
  const H = parseFloat(heightInput.value);
  const frontlap = parseFloat(frontlapInput.value)/100;
  const sidelap = parseFloat(sidelapInput.value)/100;
  const dir = parseFloat(directionInput.value)%360;

  const sensorW_m = imgW*pixelSize_m;
  const sensorH_m = imgH*pixelSize_m;
  const footprintX = H*sensorW_m/focal_m; // image width on ground [m]
  const footprintY = H*sensorH_m/focal_m; // image height on ground [m]
  stripOutput.innerHTML = `Footprint: ${footprintX.toFixed(2)} m x ${footprintY.toFixed(2)} m`;

  // prepare polygon (GeoJSON)
  const poly = turf.polygon(polygon.toGeoJSON().geometry.coordinates);
  const centroid = turf.centroid(poly);
  const rotatedPoly = turf.transformRotate(poly, -dir, { pivot: centroid });
  const bbox = turf.bbox(rotatedPoly); // [minX,minY,maxX,maxY] in lon/lat

  // spacing in meters
  const stripSpacing = footprintX*(1-sidelap);
  const photoSpacing = footprintY*(1-frontlap);

  const minX = bbox[0], maxX = bbox[2];
  const bboxCenter = [(bbox[0]+bbox[2])/2, (bbox[1]+bbox[3])/2];
  const leftPoint = turf.point([minX, bboxCenter[1]]);
  const rightPoint = turf.point([maxX, bboxCenter[1]]);
  const totalWidth_km = turf.distance(leftPoint, rightPoint, {units:'kilometers'});
  const totalWidth_m = totalWidth_km*1000;
  // More accurate strip calculation - use less padding
  let numStrips = Math.ceil((totalWidth_m + stripSpacing) / stripSpacing);
  const startPoint = turf.destination(leftPoint, (-stripSpacing)/1000, 90, {units:'kilometers'});

  let totalPhotos = 0;
  let totalStripLengthKm = 0;
  let actualStripCount = 0; // Track actual strips drawn
  
  // Reset photo points storage
  allPhotoPoints = [];
  filteredPhotoPoints = [];
  
  for(let i=0;i<numStrips;i++){
    const offset_m = i*stripSpacing;
    const offsetPoint = turf.destination(startPoint, offset_m/1000, 90, {units:'kilometers'});
    const top = turf.destination(offsetPoint, 20000/1000, 0, {units:'kilometers'});
    const bottom = turf.destination(offsetPoint, 20000/1000, 180, {units:'kilometers'});
    const line = turf.lineString([bottom.geometry.coordinates, top.geometry.coordinates]);

    const split = turf.lineSplit(line, rotatedPoly);
    let stripSegments = 0;
    let pointIndexInStrip = 0;
    
    split.features.forEach(seg=>{
      const segMid = turf.midpoint(turf.point(seg.geometry.coordinates[0]), turf.point(seg.geometry.coordinates[seg.geometry.coordinates.length-1]));
      if(turf.booleanPointInPolygon(segMid, rotatedPoly)){
        const segBack = turf.transformRotate(seg, dir, { pivot: centroid });
        const latlngs = segBack.geometry.coordinates.map(c=>[c[1], c[0]]);
        L.polyline(latlngs, {color:'green'}).addTo(layerStrips);
        stripSegments++;

        const segLength_km = turf.length(seg, {units:'kilometers'});
        const segLength_m = segLength_km*1000;
        totalStripLengthKm += segLength_km;
        if(segLength_m < 1) return;
        const stepCount = Math.floor(segLength_m / photoSpacing);
        for(let s=0;s<=stepCount;s++){
          const dist_km = (s * photoSpacing)/1000;
          const ptOnSeg = turf.along(seg, dist_km, {units:'kilometers'});
          const ptBack = turf.transformRotate(ptOnSeg, dir, { pivot: centroid });
          const coords = ptBack.geometry.coordinates; // [lng,lat]
          if(turf.booleanPointInPolygon(ptBack, poly)){
            const marker = L.circleMarker([coords[1], coords[0]], {radius:3, color:'red'}).addTo(layerPhotos);
            totalPhotos++;
            
            // Store photo point with metadata for filtering
            allPhotoPoints.push({
              lat: coords[1],
              lng: coords[0],
              stripIndex: actualStripCount,
              pointIndex: pointIndexInStrip,
              marker: marker
            });
            pointIndexInStrip++;
          }
        }
      }
    });
    if(stripSegments > 0) actualStripCount++;
  }

  // Validation check: compare calculated vs actual strips
  // Only show warning if there's a significant discrepancy (>2 strips difference)
  let stripWarning = '';
  const stripDiff = Math.abs(actualStripCount - numStrips);
  if (stripDiff > 2) {
    stripWarning = `<div class=\"warning\">Hinweis: Berechnete Streifen (${numStrips}) wurden auf tatsächliche (${actualStripCount}) korrigiert</div>`;
  }
  // Always use actual count for summary to be accurate
  numStrips = actualStripCount;

  // Calculate summary stats
  const areaHa = turf.area(poly) / 10000; // hectares
  const estFlightTimeMin = (totalStripLengthKm / 0.6) * 60; // assuming 10 m/s = 0.6 km/min

  summaryStats = {
    areaHa: areaHa.toFixed(2),
    numStrips: numStrips,
    numPhotos: totalPhotos,
    totalLengthKm: totalStripLengthKm.toFixed(2),
    estTimeMin: Math.ceil(estFlightTimeMin)
  };

  // Render summary table with formatted numbers for German locale
  try {
    summaryTable.innerHTML = `
      <tr><td>${t('summaryArea')}</td><td>${formatNumberDE(parseFloat(summaryStats.areaHa))} ha</td></tr>
      <tr><td>${t('summaryStrips')}</td><td>${summaryStats.numStrips}</td></tr>
      <tr><td>${t('summaryPhotos')}</td><td>${summaryStats.numPhotos}</td></tr>
      <tr><td>${t('summaryLength')}</td><td>${formatNumberDE(parseFloat(summaryStats.totalLengthKm))} km</td></tr>
      <tr><td>${t('summaryTime')}</td><td>${summaryStats.estTimeMin} min</td></tr>
    `;
  } catch (error) {
    console.error('Error rendering summary table:', error);
    summaryTable.innerHTML = `
      <tr><td colspan="2">Error rendering summary: ${error.message}</td></tr>
    `;
  }
  
  // Always show summary div
  summaryDiv.style.display = 'block';
  
  // Show warning if strip count mismatch
  if (stripWarning) {
    document.getElementById('summaryWarning').innerHTML = stripWarning;
  } else {
    document.getElementById('summaryWarning').innerHTML = '';
  }
  
  // Show photo filter controls
  photoFilterDiv.style.display = 'block';
  exportKmlBtn.style.display = 'inline-block';
  
  // Fetch elevation data for all points
  addElevationData();
};

// Store all photo points for filtering
let allPhotoPoints = [];
let filteredPhotoPoints = [];

// Photo point filtering
function applyPhotoFilter() {
  const keepCount = parseInt(filterCountInput.value) || 0;
  if (keepCount === 0) {
    // Reset to show all points
    layerPhotos.clearLayers();
    allPhotoPoints.forEach(pt => {
      L.circleMarker([pt.lat, pt.lng], {radius: 3, color: 'red'}).addTo(layerPhotos);
    });
    filteredPhotoPoints = [...allPhotoPoints];
    return;
  }
  
  // Clear current photo points
  layerPhotos.clearLayers();
  filteredPhotoPoints = [];
  
  // Group points by strip (based on proximity and order)
  const stripGroups = [];
  let currentStrip = [];
  let lastPoint = null;
  
  // Sort points by their order along strips
  const sortedPoints = [...allPhotoPoints].sort((a, b) => {
    if (a.stripIndex !== b.stripIndex) return a.stripIndex - b.stripIndex;
    return a.pointIndex - b.pointIndex;
  });
  
  // Re-add only the filtered points
  sortedPoints.forEach(pt => {
    const stripIdx = pt.stripIndex;
    const pointIdx = pt.pointIndex;
    const totalPointsInStrip = allPhotoPoints.filter(p => p.stripIndex === stripIdx).length;
    
    // Keep points at start and end
    if (pointIdx < keepCount || pointIdx >= totalPointsInStrip - keepCount) {
      L.circleMarker([pt.lat, pt.lng], {radius: 3, color: 'red'}).addTo(layerPhotos);
      filteredPhotoPoints.push(pt);
    }
  });
  
  // Update summary with filtered count
  summaryStats.numPhotos = filteredPhotoPoints.length;
  summaryTable.innerHTML = `
    <tr><td>${t('summaryArea')}</td><td>${formatNumberDE(parseFloat(summaryStats.areaHa))} ha</td></tr>
    <tr><td>${t('summaryStrips')}</td><td>${summaryStats.numStrips}</td></tr>
    <tr><td>${t('summaryPhotos')}</td><td>${summaryStats.numPhotos}</td></tr>
    <tr><td>${t('summaryLength')}</td><td>${formatNumberDE(parseFloat(summaryStats.totalLengthKm))} km</td></tr>
    <tr><td>${t('summaryTime')}</td><td>${summaryStats.estTimeMin} min</td></tr>
  `;
}

applyFilterBtn.onclick = applyPhotoFilter;
resetFilterBtn.onclick = () => {
  filterCountInput.value = 0;
  applyPhotoFilter();
};

// Export functions
exportCsvBtn.onclick = () => {
  const csv = `Key,Value\nArea (ha),${summaryStats.areaHa}\nStrips,${summaryStats.numStrips}\nPhotos,${summaryStats.numPhotos}\nLength (km),${summaryStats.totalLengthKm}\nTime (min),${summaryStats.estTimeMin}`;
  const blob = new Blob([csv], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'drone-plan-summary.csv';
  a.click();
  URL.revokeObjectURL(url);
};

exportJsonBtn.onclick = () => {
  const json = JSON.stringify(summaryStats, null, 2);
  const blob = new Blob([json], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'drone-plan-summary.json';
  a.click();
  URL.revokeObjectURL(url);
};

// KML Export
exportKmlBtn.onclick = () => {
  const pointsToExport = filteredPhotoPoints.length > 0 ? filteredPhotoPoints : allPhotoPoints;
  
  console.log("Exporting KML with points:", pointsToExport);
  console.log("Strip elevations:", window.stripElevations);
  
  let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
  <name>Drone Flight Plan</name>
  <description>Flight strips and photo points</description>
  
  <Style id="stripStyle">
    <LineStyle>
      <color>ff00ff00</color>
      <width>2</width>
    </LineStyle>
  </Style>
  
  <Style id="photoStyle">
    <IconStyle>
      <color>ff0000ff</color>
      <scale>0.5</scale>
      <Icon>
        <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>
      </Icon>
    </IconStyle>
  </Style>`;
  
  // Add strips
  layerStrips.eachLayer(layer => {
    if (layer instanceof L.Polyline) {
      const layerId = L.stamp(layer);
      const stripPoints = window.stripElevations && window.stripElevations[layerId] ? window.stripElevations[layerId] : null;
      let coordsStr;
      if (stripPoints) {
        coordsStr = stripPoints.map(p => {
          const alt = p.absoluteAltitude !== undefined ? p.absoluteAltitude.toFixed(2) : 0;
          console.log(`Strip point: ${p.lng},${p.lat},${alt}`);
          return `${p.lng},${p.lat},${alt}`;
        }).join(' ');
      } else {
        coordsStr = layer.getLatLngs().map(ll => `${ll.lng},${ll.lat},0`).join(' ');
        console.warn("No strip elevation data found, using 0 altitude");
      }
      kml += `
  <Placemark>
    <name>Flight Strip</name>
    <styleUrl>#stripStyle</styleUrl>
    <LineString>
      <coordinates>${coordsStr}</coordinates>
      <altitudeMode>absolute</altitudeMode>
      <extrude>1</extrude>
    </LineString>
  </Placemark>`;
    }
  });
  
  // Add photo points
  pointsToExport.forEach((pt, idx) => {
    const altitude = pt.absoluteAltitude !== undefined ? pt.absoluteAltitude.toFixed(2) : 0;
    console.log(`Photo point ${idx}: ${pt.lng},${pt.lat},${altitude}`);
    kml += `
  <Placemark>
    <name>Photo ${idx + 1}</name>
    <styleUrl>#photoStyle</styleUrl>
    <Point>
      <coordinates>${pt.lng},${pt.lat},${altitude}</coordinates>
      <altitudeMode>absolute</altitudeMode>
      <extrude>1</extrude>
    </Point>
  </Placemark>`;
  });
  
  kml += '\n</Document>\n</kml>';
  
  console.log("Generated KML:", kml);
  
  const blob = new Blob([kml], {type: 'application/vnd.google-earth.kml+xml'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'drone-flight-plan.kml';
  a.click();
  URL.revokeObjectURL(url);
};

// Language toggle
document.getElementById('langToggle').onclick = () => {
  setLanguage(currentLang === 'de' ? 'en' : 'de');
};

// initial check
async function fetchElevationsBatch(points) {
  if (!points || points.length === 0) return [];
  
  // Defensive: create if missing
  let loadingDiv = document.getElementById('loadingElevation');
  if (!loadingDiv) {
    loadingDiv = document.createElement("div");
    loadingDiv.id = "loadingElevation";
    loadingDiv.style.display = "block";
    loadingDiv.style.marginTop = "1rem";
    loadingDiv.style.fontWeight = "bold";
    loadingDiv.textContent = "Loading elevation data...";
    const sidebar = document.getElementById("sidebar");
    if (sidebar) sidebar.appendChild(loadingDiv);
    else document.body.appendChild(loadingDiv);
    console.warn("loadingElevation div was missing, created on-the-fly!");
  } else {
    loadingDiv.style.display = 'block';
  }

  try {
    // Remove invalid points
    const validPoints = points.filter(
      (p) => typeof p.lat === "number" && typeof p.lng === "number" && !isNaN(p.lat) && !isNaN(p.lng)
    );
    if (validPoints.length !== points.length) {
      console.warn("Some invalid points were filtered out:", points.length - validPoints.length);
    }

    const batchSize = 1000;
    const allElevations = [];

    for (let i = 0; i < validPoints.length; i += batchSize) {
      const batch = validPoints.slice(i, i + batchSize);
      const locations = batch.map(p => ({ latitude: p.lat, longitude: p.lng }));

      // Log payload being sent
      console.log("Sending to Open Elevation:", JSON.stringify({ locations }));

      const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ locations })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log("Open Elevation response:", data);

      if (data && Array.isArray(data.results)) {
        allElevations.push(...data.results.map(r => (
          (typeof r.elevation === "number" && !isNaN(r.elevation)) ? r.elevation : 0
        )));
      } else {
        console.error("Unexpected results from Open Elevation:", data);
        allElevations.push(...new Array(batch.length).fill(0));
      }

      // Update progress text
      if (loadingDiv) {
        const progress = Math.min(((i + batchSize) / validPoints.length) * 100, 100);
        loadingDiv.textContent = `Loading elevation data... ${Math.round(progress)}%`;
      }
    }

    if (loadingDiv) loadingDiv.style.display = 'none';

    // Return elevations aligned with input order (fallback to 0 for skipped)
    if (validPoints.length !== points.length) {
      // Create a map to assign elevations back to original point indices
      let elevationIdx = 0;
      const elevations = points.map((pt) => {
        if (
          typeof pt.lat === "number" && typeof pt.lng === "number" &&
          !isNaN(pt.lat) && !isNaN(pt.lng)
        ) {
          return allElevations[elevationIdx++];
        } else {
          return 0;
        }
      });
      console.log("Final elevations array:", elevations);
      return elevations;
    } else {
      console.log("Final elevations array:", allElevations);
      return allElevations;
    }
  } catch (error) {
    console.error('Error fetching elevations:', error);
    if (loadingDiv) loadingDiv.style.display = 'none';
    return new Array(points.length).fill(0);
  }
}
// Add elevation data to photo points and strips
async function addElevationData() {
  if (!allPhotoPoints || allPhotoPoints.length === 0) return;
  
  // Collect all unique points (photo points and strip vertices)
  const pointsToFetch = [];
  const pointIndexMap = new Map(); // Map to track which elevation belongs to which point
  
  // Add photo points
  allPhotoPoints.forEach((pt, idx) => {
    pointsToFetch.push({ lat: pt.lat, lng: pt.lng, type: 'photo', index: idx });
  });
  
  // Add strip vertices
  layerStrips.eachLayer(layer => {
    if (layer instanceof L.Polyline) {
      const latlngs = layer.getLatLngs();
      latlngs.forEach((ll, idx) => {
        pointsToFetch.push({ lat: ll.lat, lng: ll.lng, type: 'strip', layerId: L.stamp(layer), index: idx });
      });
    }
  });
  
  console.log("Points to fetch elevation for:", pointsToFetch);
  
  // Fetch elevations for all points
  const elevations = await fetchElevationsBatch(pointsToFetch);
  
  console.log("Elevations returned:", elevations);
  
  // Apply elevations to photo points
  allPhotoPoints.forEach((pt, idx) => {
    const elevation = elevations[idx] || 0;
    const flightHeight = parseFloat(heightInput.value) || 0;
    pt.elevation = elevation;
    pt.absoluteAltitude = elevation + flightHeight;
    console.log(`Photo point ${idx}: elevation=${elevation}, flightHeight=${flightHeight}, absoluteAltitude=${pt.absoluteAltitude}`);
  });
  
  // Apply elevations to filtered points as well
  if (filteredPhotoPoints.length > 0) {
    filteredPhotoPoints.forEach(pt => {
      const originalPoint = allPhotoPoints.find(p => p.lat === pt.lat && p.lng === pt.lng);
      if (originalPoint) {
        pt.elevation = originalPoint.elevation;
        pt.absoluteAltitude = originalPoint.absoluteAltitude;
      }
    });
  }
  
  // Store strip elevations for KML export
  window.stripElevations = {};
  let elevationIndex = allPhotoPoints.length; // Start after photo points
  
  layerStrips.eachLayer(layer => {
    if (layer instanceof L.Polyline) {
      const layerId = L.stamp(layer);
      const latlngs = layer.getLatLngs();
      const stripPoints = latlngs.map((ll, idx) => {
        const elevation = elevations[elevationIndex + idx] || 0;
        const flightHeight = parseFloat(heightInput.value) || 0;
        return {
          lat: ll.lat,
          lng: ll.lng,
          elevation: elevation,
          absoluteAltitude: elevation + flightHeight
        };
      });
      window.stripElevations[layerId] = stripPoints;
      console.log(`Strip ${layerId} points with elevation:`, stripPoints);
      elevationIndex += latlngs.length;
    }
  });
}
checkReady();
</script>
</body>
</html>
