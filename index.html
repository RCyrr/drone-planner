<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Drone Planner – GitHub Pages Optimiert</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<style>
body { margin:0; font-family:sans-serif; display:flex; height:100vh; }
#sidebar { width:360px; background:#fafafa; padding:1rem; overflow-y:auto; border-right:1px solid #ddd; }
#map { flex-grow:1; }
h3{margin-top:1rem;}
.output{background:#efefef; padding:.5rem; border-radius:8px; margin-top:.5rem;}
label{display:block; margin-top:.5rem;}
input, select{width:100%; padding:.3rem; margin-top:.2rem;}
button{margin-top:.5rem; padding:.5rem 1rem;}
</style>
</head>
<body>
<div id="sidebar">
<h2>Drone Planner</h2>
<h3>1. Bild / Drohne</h3>
<input type="file" id="imageInput" accept="image/jpeg" />
<label>Drohne:</label>
<select id="droneSelect">
<option value="DJI Mini 4 Pro">DJI Mini 4 Pro</option>
<option value="DJI Air 3">DJI Air 3</option>
<option value="DJI Mavic 3E">DJI Mavic 3E</option>
<option value="DJI Mavic 3 Pro">DJI Mavic 3 Pro</option>
<option value="DJI Mavic 3 Classic">DJI Mavic 3 Classic</option>
<option value="DJI Mavic 3 Enterprise">DJI Mavic 3 Enterprise</option>
<option value="DJI Mini 3 Pro">DJI Mini 3 Pro</option>
<option value="DJI Mini 3 SE">DJI Mini 3 SE</option>
<option value="DJI Matrice 300 RTK">DJI Matrice 300 RTK</option>
<option value="DJI Matrice 350 RTK">DJI Matrice 350 RTK</option>
</select>
<label>Brennweite [mm]:</label>
<input type="number" id="focalLength" placeholder="Auto / EXIF" />
<label>Pixelgröße [µm]:</label>
<input type="number" id="pixelSize" placeholder="Auto / Drohnen-Daten" readonly />
<div id="exifOutput" class="output"></div>
<h3>2. Flugplanung</h3>
<p>Polygon zeichnen:</p>
<button id="drawPolygonBtn">Polygon zeichnen</button>
<button id="clearPolygonBtn">Polygon löschen</button>
<label>Flugrichtung [° 0=Nord, 90=Ost]:</label>
<input type="number" id="flightDirection" value="0" min="0" max="359" />
<label>GSD [cm/pixel]:</label>
<input type="number" id="gsd" value="2" min="0.1" step="0.1" />
<label>Flughöhe [m]:</label>
<input type="number" id="height" value="50" min="1" step="1" />
<label>Längsüberlappung [%]:</label>
<input type="number" id="frontlap" value="70" min="0" max="99" />
<label>Querüberlappung [%]:</label>
<input type="number" id="sidelap" value="60" min="0" max="99" />
<button id="calcStrips">Flugstreifen berechnen</button>
<div id="stripOutput" class="output"></div>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exifr/dist/lite.umd.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/turf/6.5.0/turf.min.js"></script>
<script>
const DRONE_DATABASE = {
"DJI Mini 4 Pro":{pixelSize_um:1.22,focalLength_mm:24,sensorWidth_px:8064,sensorHeight_px:6048},
"DJI Air 3":{pixelSize_um:2.4,focalLength_mm:24,sensorWidth_px:7000,sensorHeight_px:5000},
"DJI Mavic 3E":{pixelSize_um:2.4,focalLength_mm:35,sensorWidth_px:8192,sensorHeight_px:5460},
"DJI Mavic 3 Pro":{pixelSize_um:2.4,focalLength_mm:28,sensorWidth_px:8192,sensorHeight_px:5460},
"DJI Mavic 3 Classic":{pixelSize_um:2.4,focalLength_mm:24,sensorWidth_px:8192,sensorHeight_px:5460},
"DJI Mavic 3 Enterprise":{pixelSize_um:2.4,focalLength_mm:35,sensorWidth_px:8192,sensorHeight_px:5460},
"DJI Mini 3 Pro":{pixelSize_um:1.55,focalLength_mm:24,sensorWidth_px:4000,sensorHeight_px:3000},
"DJI Mini 3 SE":{pixelSize_um:1.55,focalLength_mm:24,sensorWidth_px:4000,sensorHeight_px:3000},
"DJI Matrice 300 RTK":{pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648},
"DJI Matrice 350 RTK":{pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648}
};

// Map initialisieren
const map=L.map('map').setView([48.137,11.575],13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
const drawnItems=new L.FeatureGroup().addTo(map);
const drawControl=new L.Control.Draw({draw:{polygon:{allowIntersection:false},polyline:false,rectangle:false,circle:false,marker:false,circlemarker:false},edit:{featureGroup:drawnItems}});
map.addControl(drawControl);
let polygon=null;

// Polygon Buttons
const drawBtn=document.getElementById('drawPolygonBtn');
drawBtn.onclick=()=>{ if(!L.Draw){ alert('Leaflet Draw nicht geladen!'); return;} new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable();};
const clearBtn=document.getElementById('clearPolygonBtn');
clearBtn.onclick=()=>{ drawnItems.clearLayers(); polygon=null; clearStrips(); };
map.on(L.Draw.Event.CREATED,function(e){ drawnItems.clearLayers(); polygon=e.layer; if(!(polygon instanceof L.Polygon)){ alert('Fehler: Kein Polygon erstellt!'); polygon=null; return;} drawnItems.addLayer(polygon); });

// EXIF / Drohnenwerte
const imageInput=document.getElementById('imageInput');
const exifBox=document.getElementById('exifOutput');
const droneSelect=document.getElementById('droneSelect');
const focalInput=document.getElementById('focalLength');
const pixelInput=document.getElementById('pixelSize');
function updatePixelDisplay(){ const drone=DRONE_DATABASE[droneSelect.value]; pixelInput.value=drone.pixelSize_um; }
updatePixelDisplay();
droneSelect.addEventListener('change',()=>{updatePixelDisplay(); updateHeight();});
imageInput.addEventListener('change',async()=>{ const file=imageInput.files[0]; if(!file) return; const exif=await exifr.parse(file); exifBox.innerHTML=''; if(exif){ exifBox.innerHTML=`Lat: ${exif.latitude}, Lon: ${exif.longitude}<br>Width: ${exif.ExifImageWidth||'-'}, Height: ${exif.ExifImageHeight||'-'}, Focal: ${exif.FocalLength||'-'}mm`; if(exif.latitude&&exif.longitude)L.marker([exif.latitude,exif.longitude]).addTo(map).bindPopup('Bildposition').openPopup(); if(exif.FocalLength&&!focalInput.value) focalInput.value=exif.FocalLength; }});

// GSD ↔ Höhe Berechnung
const gsdInput=document.getElementById('gsd');
const heightInput=document.getElementById('height');
function updateHeight(){
  const drone=DRONE_DATABASE[droneSelect.value];
  const pixelSize_m=(parseFloat(pixelInput.value)||drone.pixelSize_um)*1e-6;
  const focal_m=(parseFloat(focalInput.value)||drone.focalLength_mm)*1e-3;
  const gsd_m=parseFloat(gsdInput.value)/100;
  if(isNaN(gsd_m) || isNaN(focal_m) || isNaN(pixelSize_m)){ alert('Parameter ungültig!'); return; }
  const H = gsd_m * focal_m / pixelSize_m;
  heightInput.value=H.toFixed(2);
}
function updateGSD(){
  const drone=DRONE_DATABASE[droneSelect.value];
  const pixelSize_m=(parseFloat(pixelInput.value)||drone.pixelSize_um)*1e-6;
  const focal_m=(parseFloat(focalInput.value)||drone.focalLength_mm)*1e-3;
  const H=parseFloat(heightInput.value);
  if(isNaN(H) || isNaN(focal_m) || isNaN(pixelSize_m)){ alert('Parameter ungültig!'); return; }
  const gsd_cm = H * pixelSize_m / focal_m * 100;
  gsdInput.value=gsd_cm.toFixed(2);
}
gsdInput.addEventListener('input',updateHeight);
heightInput.addEventListener('input',updateGSD);

// Flugstreifen
const frontlapInput=document.getElementById('frontlap');
const sidelapInput=document.getElementById('sidelap');
const directionInput=document.getElementById('flightDirection');
const calcBtn=document.getElementById('calcStrips');
const stripOutput=document.getElementById('stripOutput');
let stripLayers=[];
function clearStrips(){stripLayers.forEach(l=>map.removeLayer(l)); stripLayers=[];}

calcBtn.onclick=()=>{
  if(!polygon || !polygon.getBounds()){ alert('Bitte Polygon zeichnen!'); return; }
  clearStrips();

  const drone=DRONE_DATABASE[droneSelect.value];
  const pixelSize_m=(parseFloat(pixelInput.value)||drone.pixelSize_um)*1e-6;
  const focal_m=(parseFloat(focalInput.value)||drone.focalLength_mm)*1e-3;
  const imgW=drone.sensorWidth_px;
  const imgH=drone.sensorHeight_px;
  const H=parseFloat(heightInput.value);
  const frontlap=parseFloat(frontlapInput.value)/100;
  const sidelap=parseFloat(sidelapInput.value)/100;
  const dir_deg=parseFloat(directionInput.value)%360;

  if([pixelSize_m,focal_m,H,frontlap,sidelap,dir_deg].some(v=>isNaN(v))){ alert('Parameter ungültig!'); return; }

  const footprintX = H*focal_m/pixelSize_m*imgW/100;
  const footprintY = H*focal_m/pixelSize_m*imgH/100;
  stripOutput.innerHTML=`Footprint: ${footprintX.toFixed(2)}m x ${footprintY.toFixed(2)}m`;

  // Polygon in GeoJSON für Turf
  const polyGeo = polygon.toGeoJSON();
  const polyBBox = turf.bbox(polyGeo);

  // Abstand zwischen Streifen / Fotos
  const alongDist = footprintY*(1-frontlap);
  const acrossDist = footprintX*(1-sidelap);

  // Flugstreifen erzeugen (vereinfacht) parallel zur Richtung
  const angleRad = dir_deg*Math.PI/180;
  const cosA = Math.cos(angleRad), sinA = Math.sin(angleRad);

  const xMin = polyBBox[0]; const yMin = polyBBox[1];
  const xMax = polyBBox[2]; const yMax = polyBBox[3];
  const diagonal = Math.hypot(xMax-xMin, yMax-yMin);
  const numStrips = Math.ceil(diagonal/acrossDist)+1;

  for(let i=0;i<numStrips;i++){
    const offset = (i - numStrips/2)*acrossDist;
    const start = turf.transformTranslate(polyGeo,{distance:offset,unit:'meters',bearing:(dir_deg+90)%360});
    const line = turf.lineString([start.geometry.coordinates[0], start.geometry.coordinates[1]]);
    // Clip Linie mit Polygon
    // Vereinfachte Darstellung als Linie über Polygon für Anzeige
    stripLayers.push(L.polyline([[yMin,xMin],[yMax,xMax]],{color:'green'}).addTo(map));
  }
};
</script>
</body>
</html>