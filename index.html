<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Drone Planner â€“ Development Build</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<style>
body { margin:0; font-family:sans-serif; display:flex; height:100vh; }
#sidebar { width:360px; background:#fafafa; padding:1rem; overflow-y:auto; border-right:1px solid #ddd; }
#map { flex-grow:1; }
h3{margin-top:1rem;}
.output{background:#efefef; padding:.5rem; border-radius:8px; margin-top:.5rem;}
label{display:block; margin-top:.5rem;}
input, select{width:100%; padding:.3rem; margin-top:.2rem;}
button{margin-top:.5rem; padding:.5rem 1rem;}
.small{font-size:.9rem; color:#666}
.warning{color:#a00; font-weight:bold}
#langToggle { float:right; margin-top:0; padding:.3rem .6rem; font-size:.9rem; }
#summary table { width:100%; font-size:.9rem; margin-top:.5rem; border-collapse:collapse; }
#summary td { padding:.2rem; border-bottom:1px solid #ddd; }
#summary td:first-child { font-weight:bold; }
.export-btn { margin-right:.5rem; margin-top:.5rem; }

/* Mobile responsive */
@media (max-width: 768px) {
  body { flex-direction:column; }
  #sidebar { width:100%; height:50vh; position:relative; }
  #map { height:50vh; }
  button, input, select { font-size:1rem; padding:.6rem; }
  #langToggle { position:absolute; top:1rem; right:1rem; }
}
/* Emphasize tabs with clear color schemes */
.tab-btn { border: 1px solid #e5e7eb; transition: background-color .15s, color .15s, border-color .15s; }
.tab-btn.active { border-color: rgba(0,0,0,.20); }

/* Inactive palettes */
.tab-btn[data-variant="blue"]  { background:#dbeafe; color:#1e3a8a; }  /* blue-100 / blue-900 */
.tab-btn[data-variant="green"] { background:#dcfce7; color:#14532d; }  /* emerald-100 / emerald-900 */
.tab-btn[data-variant="pink"]  { background:#ffe4e6; color:#881337; }  /* rose-100 / rose-900 */
.tab-btn[data-variant="gold"]  { background:#fef3c7; color:#78350f; }  /* amber-100 / amber-900 */
.tab-btn:not(.active):hover { filter: brightness(0.97); }

/* Active palettes */
.tab-btn.active[data-variant="blue"]  { background:#2563eb; color:#fff; border-color:#1d4ed8; } /* blue-600/700 */
.tab-btn.active[data-variant="green"] { background:#16a34a; color:#fff; border-color:#15803d; } /* green-600/700 */
.tab-btn.active[data-variant="pink"]  { background:#e11d48; color:#fff; border-color:#be123c; } /* rose-600/700 */
.tab-btn.active[data-variant="gold"]  { background:#d97706; color:#fff; border-color:#b45309; } /* amber-600/700 */

/* Make key action buttons more visible if Tailwind utilities arenâ€™t enough */
button#drawPolygonBtn,
button#applyFilterBtn {
  font-weight: 600;
  box-shadow: 0 1px 2px rgba(0,0,0,0.08);
}

/* Offset content for fixed top toolbar */
body { padding-top: 56px; }
</style>
  <!-- Tailwind CSS (CDN) + config for class-based dark mode -->
  <script>
    window.tailwind = window.tailwind || {};
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            accent: '#2563eb' /* blue-600 */
          }
        }
      }
    }
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- ES Modules (load early to avoid undefined when handlers fire) -->
  <script type="module">
    import { fetchElevationsBatch, addElevationData } from './src/elevation.js';
    import { generateKml, exportKml as exportKmlModule } from './src/kml.js';
    import { calculateStrips } from './src/strips.js';
    import { initMap, bindUI } from './src/map.js';

    // Expose to window so existing inline code can call them
    window.fetchElevationsBatch = fetchElevationsBatch;
    window.addElevationData = addElevationData;
    window.generateKml = generateKml;
    window.exportKmlModule = exportKmlModule;
    window.calculateStripsModule = calculateStrips;
    window.initMapModule = initMap;
    window.bindUI = bindUI;

    console.log('ES modules loaded (head) for GitHub Pages/static hosting');
  </script>
</head>
<body>
<!-- Top toolbox bar -->
<div id="topToolbar" class="fixed top-0 left-0 right-0 z-50 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 py-2 px-4 flex items-center justify-between">
  <div class="flex items-center space-x-3">
    <span class="font-medium text-gray-700 dark:text-gray-200">Tools</span>
    <select id="toolSelect" class="border rounded px-2 py-1 text-sm dark:bg-gray-800 dark:border-gray-600">
      <option value="">Select tool...</option>
      <option value="exif-xmp-reader">EXIF+XMP READER</option>
      <option value="display-drone-flight">DISPLAY DRONE FLIGHT</option>
    </select>
    <button id="openToolPanelBtn" class="ml-2 px-2 py-1 text-sm rounded bg-blue-600 hover:bg-blue-700 text-white hidden">Open</button>
  </div>
</div>
<div id="sidebar" class="bg-white dark:bg-gray-800 p-4 overflow-y-auto">
  <div class="flex items-center justify-between mb-3">
    <h2 class="text-lg font-semibold text-gray-800 dark:text-gray-100">Drone Planner</h2>
    <div class="flex items-center space-x-2">
      <button id="langToggle" class="px-2 py-1 text-sm rounded bg-gray-200 dark:bg-gray-700">EN</button>
      <button id="darkToggle" class="px-2 py-1 text-sm rounded bg-gray-200 dark:bg-gray-700" title="Toggle theme">ðŸŒ™</button>
    </div>
  </div>
  <!-- Elevation loading indicator (moved out of the Export tab so it is visible during fetch) -->
  <div id="loadingElevation" style="display:none;margin-top:.5rem;font-weight:600" class="text-sm">Loading elevation data...</div>

  <!-- Tabs -->
  <div class="mb-3">
    <nav class="flex space-x-2" role="tablist" aria-label="Sidebar tabs">
      <button class="tab-btn px-3 py-1 rounded-md text-sm font-medium active" role="tab" aria-selected="true" data-variant="blue" data-tab="tab-image">Image / Drone</button>
      <button class="tab-btn px-3 py-1 rounded-md text-sm font-medium" role="tab" aria-selected="false" data-variant="green" data-tab="tab-flight">Flight Planning</button>
      <button class="tab-btn px-3 py-1 rounded-md text-sm font-medium" role="tab" aria-selected="false" data-variant="pink" data-tab="tab-filter">Photo Filter</button>
      <button class="tab-btn px-3 py-1 rounded-md text-sm font-medium" role="tab" aria-selected="false" data-variant="gold" data-tab="tab-export">Export</button>
    </nav>
  </div>

  <!-- Panels -->
  <div id="tab-image" class="tab-panel space-y-2">
    <h3 id="section1" class="text-sm font-semibold text-gray-700 dark:text-gray-200">1. Image / Drone</h3>
    <input type="file" id="imageInput" accept="image/jpeg" class="w-full" />
    <label id="labelDrone" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">Drohne:</label>
    <select id="droneSelect" class="w-full mt-1 p-2 rounded border">
      <option value="" disabled selected>Drohne wÃ¤hlen...</option>
      <option value="DJI Mini 4 Pro">DJI Mini 4 Pro</option>
      <option value="DJI Air 3">DJI Air 3</option>
      <option value="DJI Mavic 3E">DJI Mavic 3E</option>
      <option value="DJI Mavic 4E">DJI Mavic 4E</option>
      <option value="DJI Mini 3 Pro">DJI Mini 3 Pro</option>
      <option value="DJI Matrice 300 RTK">DJI Matrice 300 RTK</option>
      <option value="DJI Phantom 4 RTK">DJI Phantom 4 RTK</option>
      <option value="DJI Matrice 350 RTK">DJI Matrice 350 RTK</option>
      <option value="custom">Custom Drone...</option>
    </select>

    <label id="labelFocal" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">Brennweite [mm]:</label>
    <input type="number" id="focalLength" placeholder="Wird automatisch gesetzt" class="w-full p-2 rounded border"/>

    <label id="labelPixel" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">PixelgrÃ¶ÃŸe [Âµm]:</label>
    <input type="number" id="pixelSize" placeholder="Wird automatisch gesetzt" class="w-full p-2 rounded border"/>

    <div id="exifOutput" class="output bg-gray-50 dark:bg-gray-700 p-2 rounded text-sm"></div>
    <div id="droneNote" class="small text-xs text-gray-500 dark:text-gray-400"></div>
  </div>

  <div id="tab-flight" class="tab-panel hidden space-y-2">
    <h3 id="section2" class="text-sm font-semibold text-gray-700 dark:text-gray-200">2. Flight Planning</h3>
    <p id="polygonDraw" class="text-sm text-gray-600 dark:text-gray-300">Polygon zeichnen:</p>
    <div class="flex space-x-2">
      <button id="drawPolygonBtn" class="px-3 py-2 rounded-md bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-400 text-white shadow-sm">Polygon zeichnen</button>
      <button id="clearPolygonBtn" class="px-3 py-2 rounded-md bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-rose-400 text-white shadow-sm">Polygon lÃ¶schen</button>
    </div>

    <label id="labelShapefile" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">Shapefile importieren:</label>
    <input type="file" id="shapefileInput" accept=".shp" class="w-full" />

    <label id="labelDirection" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">Flugrichtung [Â° 0=Nord, 90=Ost]:</label>
    <input type="number" id="flightDirection" value="0" min="0" max="359" class="w-full p-2 rounded border"/>

    <label id="labelGsd" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">GSD [cm/pixel]:</label>
    <input type="number" id="gsd" value="2" min="0.1" step="0.1" class="w-full p-2 rounded border"/>

    <label id="labelHeight" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">FlughÃ¶he [m]:</label>
    <input type="number" id="height" value="50" min="1" step="1" class="w-full p-2 rounded border"/>

    <div class="grid grid-cols-2 gap-2">
      <div>
        <label id="labelFrontlap" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">LÃ¤ngsÃ¼berlappung [%]:</label>
        <input type="number" id="frontlap" value="70" min="0" max="99" class="w-full p-2 rounded border"/>
      </div>
      <div>
        <label id="labelSidelap" class="block mt-2 text-sm text-gray-600 dark:text-gray-300">QuerÃ¼berlappung [%]:</label>
        <input type="number" id="sidelap" value="60" min="0" max="99" class="w-full p-2 rounded border"/>
      </div>
    </div>

    <button id="calcStrips" disabled class="w-full mt-2 px-3 py-2 rounded bg-green-600 text-white">Flugstreifen berechnen</button>
    <div id="stripOutput" class="output bg-gray-50 dark:bg-gray-700 p-2 rounded text-sm"></div>

    <div id="summary" class="hidden mt-2 bg-gray-50 dark:bg-gray-700 p-2 rounded">
      <h3 id="summaryTitle" class="font-semibold text-sm text-gray-700 dark:text-gray-200">Zusammenfassung</h3>
      <div id="summaryWarning" class="warning text-red-600"></div>
      <table id="summaryTable" class="w-full text-sm mt-1"></table>
      <div class="flex space-x-2 mt-2">
        <button id="exportCsv" class="export-btn px-3 py-1 rounded border">CSV Export</button>
        <button id="exportJson" class="export-btn px-3 py-1 rounded border">JSON Export</button>
      </div>
    </div>
  </div>

  <div id="tab-filter" class="tab-panel hidden space-y-2">
    <h4 class="text-sm font-semibold text-gray-700 dark:text-gray-200">Fotopunkte filtern:</h4>
    <label for="filterCount" class="text-sm text-gray-600 dark:text-gray-300">Anzahl Punkte am Anfang/Ende behalten:</label>
    <input type="number" id="filterCount" value="3" min="0" max="50" class="w-full p-2 rounded border"/>
    <div class="flex space-x-2">
      <button id="applyFilterBtn" class="px-3 py-2 rounded-md bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-rose-400 text-white shadow-sm">Filter anwenden</button>
      <button id="resetFilterBtn" class="px-3 py-2 rounded-md bg-amber-500 hover:bg-amber-600 focus:outline-none focus:ring-2 focus:ring-amber-300 text-white shadow-sm">Filter zurÃ¼cksetzen</button>
    </div>
  </div>

  <div id="tab-export" class="tab-panel hidden space-y-2">
    <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-200">Export</h3>
    <div class="flex flex-col space-y-2">
      <button id="exportKmlBtn" class="export-btn px-3 py-2 rounded-md bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 text-white hidden">KML Export</button>
      <button id="exportCsvBtnTop" class="export-btn px-3 py-1 rounded border">CSV Export</button>
      <button id="exportJsonBtnTop" class="export-btn px-3 py-1 rounded border">JSON Export</button>
    </div>
  </div>

  <!-- Tab + theme script -->
  <script>
    (function(){
      const tabs = document.querySelectorAll('.tab-btn');
      const panels = document.querySelectorAll('.tab-panel');
      function activate(tabId){
        panels.forEach(p => p.id === tabId ? p.classList.remove('hidden') : p.classList.add('hidden'));
        tabs.forEach(btn => {
          const isActive = btn.dataset.tab === tabId;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
      }
      // default
      activate('tab-image');

      tabs.forEach(btn => {
        btn.addEventListener('click', ()=> activate(btn.dataset.tab));
      });

      // Dark mode toggle
      const darkBtn = document.getElementById('darkToggle');
      darkBtn.addEventListener('click', ()=>{
        const html = document.documentElement;
        html.classList.toggle('dark');
        darkBtn.textContent = html.classList.contains('dark') ? 'â˜€ï¸' : 'ðŸŒ™';
      });

      // Mirror top export buttons to existing handlers (keep existing IDs functioning)
      const exportCsvTop = document.getElementById('exportCsvBtnTop');
      const exportJsonTop = document.getElementById('exportJsonBtnTop');
      if(exportCsvTop){
        exportCsvTop.addEventListener('click', ()=> {
          const ev = new Event('click');
          const btn = document.getElementById('exportCsv');
          if(btn) btn.dispatchEvent(ev);
        });
      }
      if(exportJsonTop){
        exportJsonTop.addEventListener('click', ()=> {
          const ev = new Event('click');
          const btn = document.getElementById('exportJson');
          if(btn) btn.dispatchEvent(ev);
        });
      }
    })();
  </script>
</div>
<div id="map"></div>

<!-- Bibliotheken -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/exifr/dist/lite.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/shapefile@0.6.6/dist/shapefile.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
  if (!document.getElementById("loadingElevation")) {
    const loadingDiv = document.createElement("div");
    loadingDiv.id = "loadingElevation";
    loadingDiv.style.display = "none";
    loadingDiv.style.marginTop = "1rem";
    loadingDiv.style.fontWeight = "bold";
    loadingDiv.textContent = "Loading elevation data...";
    // Insert at end of sidebar (before map)
    const sidebar = document.getElementById("sidebar");
    if (sidebar) sidebar.appendChild(loadingDiv);
    else document.body.appendChild(loadingDiv);
    console.log("Inserted loadingElevation div programmatically.");
  }
});
// Expanded drone database with EXIF model tags (modelTag)
const DRONE_DATABASE = {
  "DJI Mini 4 Pro":{modelTag:'FC8482',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:2268},
  "DJI Air 3":{modelTag:'FC8282',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:2268},
  "DJI Mavic 3E":{modelTag:'M3E',pixelSize_um:3.3,focalLength_mm:12.3,sensorWidth_px:5280,sensorHeight_px:3956},
  "DJI Mavic 4E":{modelTag:'M4E',pixelSize_um:3.3,focalLength_mm:12.3,sensorWidth_px:5280,sensorHeight_px:3956},
  "DJI Mini 3 Pro":{modelTag:'FC3582',pixelSize_um:2.4,focalLength_mm:6.7,sensorWidth_px:4032,sensorHeight_px:3024},
  "DJI Matrice 300 RTK":{modelTag:'M300',pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648},
  "DJI Phantom 4 RTK":{modelTag:'FC6310R',pixelSize_um:2.4,focalLength_mm:8.8,sensorWidth_px:5472,sensorHeight_px:3648},
  "DJI Matrice 350 RTK":{modelTag:'M350',pixelSize_um:3.76,focalLength_mm:35,sensorWidth_px:5472,sensorHeight_px:3648}
};

const TRANSLATIONS = {
  de: {
    title: 'Drone Planner â€“ GitHub Pages Optimiert',
    appTitle: 'Drone Planner',
    section1: '1. Bild / Drohne',
    section2: '2. Flugplanung',
    labelDrone: 'Drohne:',
    dronePlaceholder: 'Drohne wÃ¤hlen...',
    labelFocal: 'Brennweite [mm]:',
    focalPlaceholder: 'Wird automatisch gesetzt',
    labelPixel: 'PixelgrÃ¶ÃŸe [Âµm]:',
    pixelPlaceholder: 'Wird automatisch gesetzt',
    polygonDraw: 'Polygon zeichnen:',
    drawBtn: 'Polygon zeichnen',
    clearBtn: 'Polygon lÃ¶schen',
    labelShapefile: 'Shapefile importieren:',
    labelDirection: 'Flugrichtung [Â° 0=Nord, 90=Ost]:',
    labelGsd: 'GSD [cm/pixel]:',
    labelHeight: 'FlughÃ¶he [m]:',
    labelFrontlap: 'LÃ¤ngsÃ¼berlappung [%]:',
    labelSidelap: 'QuerÃ¼berlappung [%]:',
    calcBtn: 'Flugstreifen berechnen',
    exifNone: 'Keine EXIF-Daten gefunden.',
    exifFormat: 'EXIF: Model={model}, Focal={focal}mm, Size={width}x{height}',
    droneCustomNote: 'Custom Drone: bitte Brennweite und PixelgrÃ¶ÃŸe eingeben (PixelgrÃ¶ÃŸe in Âµm)',
    droneDbNotePrefix: 'Aus Drohnendatenbank geladen: modelTag=',
    summaryTitle: 'Zusammenfassung',
    summaryArea: 'FlÃ¤che',
    summaryStrips: 'Anzahl Streifen',
    summaryPhotos: 'Anzahl Fotos',
    summaryLength: 'GesamtlÃ¤nge',
    summaryTime: 'GeschÃ¤tzte Flugzeit',
    exportCsv: 'CSV Export',
    exportJson: 'JSON Export',
    photoFilterTitle: 'Fotopunkte filtern:',
    photoFilterLabel: 'Anzahl Punkte am Anfang/Ende behalten:',
    applyFilter: 'Filter anwenden',
    resetFilter: 'Filter zurÃ¼cksetzen',
    exportKml: 'KML Export'
  },
  en: {
    title: 'Drone Planner â€“ GitHub Pages Optimized',
    appTitle: 'Drone Planner',
    section1: '1. Image / Drone',
    section2: '2. Flight Planning',
    labelDrone: 'Drone:',
    dronePlaceholder: 'Select drone...',
    labelFocal: 'Focal Length [mm]:',
    focalPlaceholder: 'Auto-filled',
    labelPixel: 'Pixel Size [Âµm]:',
    pixelPlaceholder: 'Auto-filled',
    polygonDraw: 'Draw Polygon:',
    drawBtn: 'Draw Polygon',
    clearBtn: 'Clear Polygon',
    labelShapefile: 'Import Shapefile:',
    labelDirection: 'Flight Direction [Â° 0=North, 90=East]:',
    labelGsd: 'GSD [cm/pixel]:',
    labelHeight: 'Flight Height [m]:',
    labelFrontlap: 'Front Overlap [%]:',
    labelSidelap: 'Side Overlap [%]:',
    calcBtn: 'Calculate Flight Strips',
    exifNone: 'No EXIF data found.',
    exifFormat: 'EXIF: Model={model}, Focal={focal}mm, Size={width}x{height}',
    droneCustomNote: 'Custom Drone: please enter focal length and pixel size (pixel size in Âµm)',
    droneDbNotePrefix: 'Loaded from drone database: modelTag=',
    summaryTitle: 'Summary',
    summaryArea: 'Area',
    summaryStrips: 'Number of Strips',
    summaryPhotos: 'Number of Photos',
    summaryLength: 'Total Length',
    summaryTime: 'Estimated Flight Time',
    exportCsv: 'Export CSV',
    exportJson: 'Export JSON',
    photoFilterTitle: 'Filter Photo Points:',
    photoFilterLabel: 'Points to keep at start/end:',
    applyFilter: 'Apply Filter',
    resetFilter: 'Reset Filter',
    exportKml: 'Export KML'
  }
};

let currentLang = localStorage.getItem('dronePlannerLang') || 'de';
function t(key) { return TRANSLATIONS[currentLang][key] || key; }
function setLanguage(lang) {
  currentLang = lang;
  localStorage.setItem('dronePlannerLang', lang);
  document.documentElement.lang = lang;
  document.getElementById('langToggle').textContent = lang === 'de' ? 'EN' : 'DE';
  // Update all UI texts
  document.getElementById('section1').textContent = t('section1');
  document.getElementById('section2').textContent = t('section2');
  document.getElementById('labelDrone').textContent = t('labelDrone');
  document.getElementById('droneSelect').options[0].text = t('dronePlaceholder');
  document.getElementById('labelFocal').textContent = t('labelFocal');
  document.getElementById('focalLength').placeholder = t('focalPlaceholder');
  document.getElementById('labelPixel').textContent = t('labelPixel');
  document.getElementById('pixelSize').placeholder = t('pixelPlaceholder');
  document.getElementById('polygonDraw').textContent = t('polygonDraw');
  document.getElementById('drawPolygonBtn').textContent = t('drawBtn');
  document.getElementById('clearPolygonBtn').textContent = t('clearBtn');
  document.getElementById('labelDirection').textContent = t('labelDirection');
  document.getElementById('labelGsd').textContent = t('labelGsd');
  document.getElementById('labelHeight').textContent = t('labelHeight');
  document.getElementById('labelFrontlap').textContent = t('labelFrontlap');
  document.getElementById('labelSidelap').textContent = t('labelSidelap');
  document.getElementById('calcStrips').textContent = t('calcBtn');
  document.getElementById('summaryTitle').textContent = t('summaryTitle');
  document.getElementById('exportCsv').textContent = t('exportCsv');
  document.getElementById('exportJson').textContent = t('exportJson');
  // Update photo filter UI texts
  const photoFilterTitle = photoFilterDiv.querySelector('h4');
  if (photoFilterTitle) photoFilterTitle.textContent = t('photoFilterTitle');
  const filterLabel = document.querySelector('label[for="filterCount"]');
  if (filterLabel) filterLabel.textContent = t('photoFilterLabel');
  document.getElementById('applyFilterBtn').textContent = t('applyFilter');
  document.getElementById('resetFilterBtn').textContent = t('resetFilter');
  document.getElementById('exportKmlBtn').textContent = t('exportKml');
}

const map = L.map('map').setView([48.137,11.575],13);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
const drawnItems = new L.FeatureGroup().addTo(map);
map.addLayer(drawnItems);
const drawControl = new L.Control.Draw({draw:{polygon:{allowIntersection:false},polyline:false,rectangle:false,circle:false,marker:false,circlemarker:false},edit:{featureGroup:drawnItems}});
map.addControl(drawControl);
let polygon=null;

// LayerGroups fÃ¼r Streifen & Fotos
const layerStrips = L.layerGroup().addTo(map);
const layerPhotos = L.layerGroup().addTo(map);
const overlays = { "Streifen": layerStrips, "Fotopunkte": layerPhotos };
L.control.layers({}, overlays, { collapsed:false }).addTo(map);

// UI-Elemente
const drawBtn = document.getElementById('drawPolygonBtn');
const clearBtn = document.getElementById('clearPolygonBtn');
const imageInput = document.getElementById('imageInput');
const exifBox = document.getElementById('exifOutput');
const droneSelect = document.getElementById('droneSelect');
const focalInput = document.getElementById('focalLength');
const pixelInput = document.getElementById('pixelSize');
const droneNote = document.getElementById('droneNote');
const calcBtn = document.getElementById('calcStrips');
const gsdInput = document.getElementById('gsd');
const heightInput = document.getElementById('height');
const frontlapInput = document.getElementById('frontlap');
const sidelapInput = document.getElementById('sidelap');
const directionInput = document.getElementById('flightDirection');
const stripOutput = document.getElementById('stripOutput');
const summaryDiv = document.getElementById('summary');
const summaryTable = document.getElementById('summaryTable');
const exportCsvBtn = document.getElementById('exportCsv');
const exportJsonBtn = document.getElementById('exportJson');
const shapefileInput = document.getElementById('shapefileInput');
// The photo filter panel moved into the tabbed UI. Use fallback to support both IDs.
const photoFilterDiv = document.getElementById('photoFilter') || document.getElementById('tab-filter');
const filterCountInput = document.getElementById('filterCount');
const applyFilterBtn = document.getElementById('applyFilterBtn');
const resetFilterBtn = document.getElementById('resetFilterBtn');
const exportKmlBtn = document.getElementById('exportKmlBtn');

// init state
pixelInput.readOnly = true;
focalInput.readOnly = false; // allow override even for DB entries
calcBtn.disabled = true;
setLanguage(currentLang);

// Format numbers with German decimal comma and fixed decimals
function formatNumberDE(num, decimals=2) {
  if (isNaN(num)) return '-';
  return num.toFixed(decimals).replace('.', ',');
}

function setDroneValues(name){
  if(!name || name==='') return;
  if(name==='custom'){
    // allow manual entry
    pixelInput.readOnly = false;
    focalInput.readOnly = false;
    pixelInput.value = '';
    focalInput.value = '';
    droneNote.innerText = t('droneCustomNote');
    return;
  }
  const d = DRONE_DATABASE[name];
  if(d){
    pixelInput.value = d.pixelSize_um;
    pixelInput.readOnly = true;
    focalInput.value = d.focalLength_mm;
    focalInput.readOnly = false; // user still allowed to override
    droneNote.innerText = t('droneDbNotePrefix') + d.modelTag;
  }
}

// check readiness to enable calc button
function checkReady(){
  const droneName = droneSelect.value;
  if(!droneName) { calcBtn.disabled=true; return; }
  // require focal and pixel
  const focal = parseFloat(focalInput.value);
  const pixel = parseFloat(pixelInput.value);
  const gsd = parseFloat(gsdInput.value);
  const H = parseFloat(heightInput.value);
  const hasGsdOrH = (!isNaN(gsd) && gsd>0) || (!isNaN(H) && H>0);
  const hasFocal = !isNaN(focal) && focal>0;
  const hasPixel = !isNaN(pixel) && pixel>0;
  const hasPoly = polygon instanceof L.Polygon;
  if(hasFocal && hasPixel && hasGsdOrH && hasPoly){ calcBtn.disabled=false; } else { calcBtn.disabled=true; }
}

// event hookup
droneSelect.addEventListener('change', ()=>{
  setDroneValues(droneSelect.value);
  checkReady();
});

// EXIF handling with user choice popup (Method B)
imageInput.addEventListener('change', async ()=>{
  const file = imageInput.files[0]; if(!file) return;
  const exif = await exifr.parse(file);
  exifBox.innerHTML = '';
  if(!exif){ exifBox.innerText = t('exifNone'); return; }

  const exifModel = exif.Model || exif.Make || null; // try Model first then Make
  const exifFocal = exif.FocalLength || exif.FocalLengthIn35mmFormat || null;
  const exifW = exif.ExifImageWidth || exif.PixelXDimension || null;
  const exifH = exif.ExifImageHeight || exif.PixelYDimension || null;

  exifBox.innerHTML = t('exifFormat')
    .replace('{model}', exifModel||'-')
    .replace('{focal}', exifFocal||'-')
    .replace('{width}', exifW||'-')
    .replace('{height}', exifH||'-');

  // try match drone by modelTag
  let matchedName = null;
  for(const name in DRONE_DATABASE){ const d=DRONE_DATABASE[name]; if(d.modelTag && exifModel && exifModel.toString().includes(d.modelTag)){ matchedName = name; break; } }

  // if matched and a drone is selected and matches, offer choice
  if(matchedName){
    // if selected drone matches matchedName, compare
    if(droneSelect.value && droneSelect.value!=='' && droneSelect.value!== 'custom'){
      const selected = droneSelect.value;
      if(selected===matchedName && exifFocal){
        // compare
        const dbF = DRONE_DATABASE[selected].focalLength_mm;
        const diff = Math.abs(exifFocal - dbF)/dbF;
        let msg = `EXIF Brennweite ${exifFocal}mm gefunden fÃ¼r Model ${exifModel}.
Datenbank: ${dbF}mm.`;
        if(diff>0.1) msg += "\n\nAbweichung >10% â€” mÃ¶chtest du EXIF-Wert verwenden? OK = EXIF, Abbrechen = Drohnendatenbank";
        else msg += "\n\nOK = EXIF, Abbrechen = Drohnendatenbank";
        const useExif = window.confirm(msg);
        if(useExif){ focalInput.value = exifFocal; }
        else { focalInput.value = dbF; }
      }
    } else {
      // if no selected drone, pre-select matchedName to help user
      droneSelect.value = matchedName;
      setDroneValues(matchedName);
      // if exif focal exists, ask user which to use
      if(exifFocal){
        const dbF = DRONE_DATABASE[matchedName].focalLength_mm;
        const diff = Math.abs(exifFocal - dbF)/dbF;
        let msg = `EXIF Brennweite ${exifFocal}mm gefunden fÃ¼r Model ${exifModel}.
Datenbank: ${dbF}mm.`;
        if(diff>0.1) msg += "\n\nAbweichung >10% â€” mÃ¶chtest du EXIF-Wert verwenden? OK = EXIF, Abbrechen = Drohnendatenbank";
        else msg += "\n\nOK = EXIF, Abbrechen = Drohnendatenbank";
        const useExif = window.confirm(msg);
        if(useExif){ focalInput.value = exifFocal; }
      }
    }
  } else {
    // not matched: if user wants to use EXIF focal for custom or unknown, ask
    if(exifFocal){
      const useExif = window.confirm(`EXIF Brennweite ${exifFocal}mm gefunden (Model=${exifModel}). OK = Verwenden, Abbrechen = nicht Ã¼bernehmen`);
      if(useExif){ focalInput.value = exifFocal; }
    }
    // if image size present and drone is custom, populate sensor pixels
    if(exifW && exifH && droneSelect.value==='custom'){
      // set sensor px as EXIF image size if user chooses
      pixelInput.value = pixelInput.value || '';
      // if empty, set sensor sizes implicitly by using image size for sensor px? We assume sensor px = image px for custom workflow
      if(!pixelInput.value) pixelInput.value = '';
      exifBox.innerHTML += '<br>Hinweis: BildgrÃ¶ÃŸe in EXIF erkannt â€” falls Sensordaten fehlen, bitte PixelgrÃ¶ÃŸe manuell eingeben.';
    }
  }
  checkReady();
});

// set defaults when user selects drone
setDroneValues(droneSelect.value);

// GSD <-> Height coupling
gsdInput.addEventListener('input', ()=>{
  const pixelSize_m = (parseFloat(pixelInput.value) || 0)*1e-6;
  const focal_m = (parseFloat(focalInput.value) || 0)*1e-3;
  const gsd_cm = parseFloat(gsdInput.value);
  if(!pixelSize_m || !focal_m || isNaN(gsd_cm)) return;
  const gsd_m = gsd_cm/100;
  const H = gsd_m * focal_m / pixelSize_m;
  if(!isNaN(H)) heightInput.value = H.toFixed(2);
  checkReady();
});
heightInput.addEventListener('input', ()=>{
  const pixelSize_m = (parseFloat(pixelInput.value) || 0)*1e-6;
  const focal_m = (parseFloat(focalInput.value) || 0)*1e-3;
  const H = parseFloat(heightInput.value);
  if(!pixelSize_m || !focal_m || isNaN(H)) return;
  const gsd_cm = H * pixelSize_m / focal_m * 100;
  if(!isNaN(gsd_cm)) gsdInput.value = gsd_cm.toFixed(2);
  checkReady();
});

// when focal or pixel manually edited, re-check readiness
focalInput.addEventListener('input', checkReady);
pixelInput.addEventListener('input', checkReady);
frontlapInput.addEventListener('input', checkReady);
sidelapInput.addEventListener('input', checkReady);
directionInput.addEventListener('input', checkReady);

// Shapefile import
shapefileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const reader = new FileReader();
    reader.onload = async (event) => {
      const arrayBuffer = event.target.result;
      const geojson = await shapefile.read(arrayBuffer);
      
      if (geojson.features && geojson.features.length > 0) {
        // Clear existing polygon
        drawnItems.clearLayers();
        polygon = null;
        clearStrips();
        
        // Find first polygon feature
        const polygonFeature = geojson.features.find(f =>
          f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
        );
        
        if (polygonFeature) {
          // Convert to Leaflet layer
          const layer = L.geoJSON(polygonFeature, {
            style: { color: 'blue', weight: 2 }
          });
          
          // Get the polygon geometry
          const coords = polygonFeature.geometry.type === 'Polygon'
            ? polygonFeature.geometry.coordinates
            : polygonFeature.geometry.coordinates[0];
          
          // Create Leaflet polygon
          const latlngs = coords[0].map(coord => [coord[1], coord[0]]);
          polygon = L.polygon(latlngs, { color: 'blue', weight: 2 });
          drawnItems.addLayer(polygon);
          
          // Center map on polygon
          map.fitBounds(polygon.getBounds());
          
          stripOutput.innerHTML = `Shapefile imported: ${polygonFeature.geometry.type}`;
          checkReady();
        } else {
          stripOutput.innerHTML = 'No polygon found in shapefile';
        }
      } else {
        stripOutput.innerHTML = 'Invalid shapefile or no features found';
      }
    };
    reader.readAsArrayBuffer(file);
  } catch (error) {
    stripOutput.innerHTML = `Error loading shapefile: ${error.message}`;
  }
});

// Polygon drawing
drawBtn.onclick = ()=>{ new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable(); };
clearBtn.onclick = ()=>{ drawnItems.clearLayers(); polygon=null; clearStrips(); checkReady(); };
map.on(L.Draw.Event.CREATED, function(e){
  if(e.layer instanceof L.Polygon){
    drawnItems.clearLayers();
    polygon = e.layer;
    drawnItems.addLayer(polygon);
  } else {
    polygon = null;
  }
  checkReady();
});

// Flugstreifen + Foto-Punkte (wie zuvor, unchanged)
function clearStrips(){ layerStrips.clearLayers(); layerPhotos.clearLayers(); }

let summaryStats = {};

calcBtn.onclick = async () => {
  if (!polygon) return;
  clearStrips();

  // Build drone object and options to pass to calculateStrips
  const droneName = droneSelect.value;
  const drone = DRONE_DATABASE[droneName] || {};
  const options = {
    height: parseFloat(heightInput.value) || 0,
    frontlap: parseFloat(frontlapInput.value) / 100 || 0.7,
    sidelap: parseFloat(sidelapInput.value) / 100 || 0.6,
    direction: parseFloat(directionInput.value) % 360 || 0,
    minSegmentLength: 1
  };

  // Provide sensor sizes if available
  if (drone && drone.sensorWidth_px) drone.sensorWidth_px = drone.sensorWidth_px;
  if (drone && drone.sensorHeight_px) drone.sensorHeight_px = drone.sensorHeight_px;
  // allow user-overrides from inputs
  drone.pixelSize_um = parseFloat(pixelInput.value) || drone.pixelSize_um;
  drone.focalLength_mm = parseFloat(focalInput.value) || drone.focalLength_mm;
  drone.sensorWidth_px = drone.sensorWidth_px || parseInt(exifBox.dataset.imgw) || drone.sensorWidth_px;
  drone.sensorHeight_px = drone.sensorHeight_px || parseInt(exifBox.dataset.imgh) || drone.sensorHeight_px;

  // Convert the Leaflet polygon to GeoJSON polygon to pass to the module
  const polygonGeoJSON = polygon.toGeoJSON().geometry;
  try {
    // Ensure module binding exists (dynamic import fallback in case head bootstrap failed)
    if (!window.calculateStripsModule) {
      const mod = await import('./src/strips.js');
      window.calculateStripsModule = mod.calculateStrips;
      console.log('Loaded strips module dynamically as fallback');
    }
    const result = window.calculateStripsModule(polygonGeoJSON, drone, options);
    const { photoPoints, stripLines, summaryStats: newSummary } = result;

    // Render strips returned (stripLines are arrays of [lng,lat] points)
    stripLines.forEach((strip) => {
      if (strip && strip.coordinates && strip.coordinates.length > 0) {
        const latlngs = strip.coordinates.map(c => [c[1], c[0]]); // convert to [lat,lng]
        L.polyline(latlngs, { color: 'green' }).addTo(layerStrips);
      }
    });

    // Render photo points and populate allPhotoPoints
    allPhotoPoints = [];
    filteredPhotoPoints = [];
    photoPoints.forEach((pt, idx) => {
      const marker = L.circleMarker([pt.lat, pt.lng], { radius: 3, color: 'red' }).addTo(layerPhotos);
      allPhotoPoints.push({
        lat: pt.lat,
        lng: pt.lng,
        stripIndex: pt.stripIndex,
        pointIndex: pt.pointIndex,
        marker: marker
      });
    });

    // Apply summary stats returned
    summaryStats = {
      areaHa: newSummary.areaHa,
      numStrips: newSummary.numStrips,
      numPhotos: newSummary.numPhotos,
      totalLengthKm: newSummary.totalLengthKm,
      estTimeMin: newSummary.estTimeMin
    };

    // Render summary table
    summaryTable.innerHTML = `
      <tr><td>${t('summaryArea')}</td><td>${formatNumberDE(parseFloat(summaryStats.areaHa))} ha</td></tr>
      <tr><td>${t('summaryStrips')}</td><td>${summaryStats.numStrips}</td></tr>
      <tr><td>${t('summaryPhotos')}</td><td>${summaryStats.numPhotos}</td></tr>
      <tr><td>${t('summaryLength')}</td><td>${formatNumberDE(parseFloat(summaryStats.totalLengthKm))} km</td></tr>
      <tr><td>${t('summaryTime')}</td><td>${summaryStats.estTimeMin} min</td></tr>
    `;

    // Show UI controls
    if (summaryDiv) {
      summaryDiv.classList.remove('hidden');
      summaryDiv.style.display = 'block';
    }
    // For tabbed UI: only force-display legacy photoFilter panel (if present).
    if (photoFilterDiv && photoFilterDiv.id === 'photoFilter') {
      photoFilterDiv.style.display = 'block';
    }
    if (exportKmlBtn) {
      exportKmlBtn.classList.remove('hidden');
      exportKmlBtn.style.display = 'inline-block';
    }

    // Fetch elevations asynchronously and apply (use module-bound function)
    if (!window.addElevationData) {
      try {
        const mod = await import('./src/elevation.js');
        window.addElevationData = mod.addElevationData;
        console.log('Loaded elevation module dynamically as fallback');
      } catch (e) {
        console.error('Failed to load elevation module dynamically:', e);
      }
    }
    if (window.addElevationData) {
      await window.addElevationData();
    }

  } catch (err) {
    console.error('Error calculating strips:', err);
    stripOutput.innerHTML = `Error calculating strips: ${err.message}`;
  }
};

// Store all photo points for filtering
let allPhotoPoints = [];
let filteredPhotoPoints = [];

// Photo point filtering
function applyPhotoFilter() {
  const keepCount = parseInt(filterCountInput.value) || 0;
  if (keepCount === 0) {
    // Reset to show all points
    layerPhotos.clearLayers();
    allPhotoPoints.forEach(pt => {
      L.circleMarker([pt.lat, pt.lng], {radius: 3, color: 'red'}).addTo(layerPhotos);
    });
    filteredPhotoPoints = [...allPhotoPoints];
    return;
  }
  
  // Clear current photo points
  layerPhotos.clearLayers();
  filteredPhotoPoints = [];
  
  // Group points by strip (based on proximity and order)
  const stripGroups = [];
  let currentStrip = [];
  let lastPoint = null;
  
  // Sort points by their order along strips
  const sortedPoints = [...allPhotoPoints].sort((a, b) => {
    if (a.stripIndex !== b.stripIndex) return a.stripIndex - b.stripIndex;
    return a.pointIndex - b.pointIndex;
  });
  
  // Re-add only the filtered points
  sortedPoints.forEach(pt => {
    const stripIdx = pt.stripIndex;
    const pointIdx = pt.pointIndex;
    const totalPointsInStrip = allPhotoPoints.filter(p => p.stripIndex === stripIdx).length;
    
    // Keep points at start and end
    if (pointIdx < keepCount || pointIdx >= totalPointsInStrip - keepCount) {
      L.circleMarker([pt.lat, pt.lng], {radius: 3, color: 'red'}).addTo(layerPhotos);
      filteredPhotoPoints.push(pt);
    }
  });
  
  // Update summary with filtered count
  summaryStats.numPhotos = filteredPhotoPoints.length;
  summaryTable.innerHTML = `
    <tr><td>${t('summaryArea')}</td><td>${formatNumberDE(parseFloat(summaryStats.areaHa))} ha</td></tr>
    <tr><td>${t('summaryStrips')}</td><td>${summaryStats.numStrips}</td></tr>
    <tr><td>${t('summaryPhotos')}</td><td>${summaryStats.numPhotos}</td></tr>
    <tr><td>${t('summaryLength')}</td><td>${formatNumberDE(parseFloat(summaryStats.totalLengthKm))} km</td></tr>
    <tr><td>${t('summaryTime')}</td><td>${summaryStats.estTimeMin} min</td></tr>
  `;
}

applyFilterBtn.onclick = applyPhotoFilter;
resetFilterBtn.onclick = () => {
  filterCountInput.value = 0;
  applyPhotoFilter();
};

// Export functions
exportCsvBtn.onclick = () => {
  const csv = `Key,Value\nArea (ha),${summaryStats.areaHa}\nStrips,${summaryStats.numStrips}\nPhotos,${summaryStats.numPhotos}\nLength (km),${summaryStats.totalLengthKm}\nTime (min),${summaryStats.estTimeMin}`;
  const blob = new Blob([csv], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'drone-plan-summary.csv';
  a.click();
  URL.revokeObjectURL(url);
};

exportJsonBtn.onclick = () => {
  const json = JSON.stringify(summaryStats, null, 2);
  const blob = new Blob([json], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'drone-plan-summary.json';
  a.click();
  URL.revokeObjectURL(url);
};

// KML Export (uses kml module)
exportKmlBtn.onclick = async () => {
  const pts = filteredPhotoPoints.length > 0 ? filteredPhotoPoints : allPhotoPoints;
  const stripElevs = window.stripElevations || {};
  console.log("Exporting KML via module, points:", pts, "stripElevs:", stripElevs);
  // Ensure module function exists (fallback if head bootstrap failed)
  if (!window.exportKmlModule) {
    try {
      const mod = await import('./src/kml.js');
      window.exportKmlModule = mod.exportKml;
      window.generateKml = mod.generateKml;
      console.log('Loaded kml module dynamically as fallback');
    } catch (e) {
      console.error('Failed to load kml module dynamically:', e);
      return;
    }
  }
  // Generate & download via module helper
  window.exportKmlModule(pts, stripElevs, 'drone-flight-plan.kml', { title: 'Drone Flight Plan', description: 'Flight strips and photo points' });
};

// Language toggle
document.getElementById('langToggle').onclick = () => {
  setLanguage(currentLang === 'de' ? 'en' : 'de');
};

// initial check
checkReady();

// EXIF/XMP Reader Tool (robust init with retries to avoid race conditions)
let exifxmp_lastMeta = null;
function exifxmp_parseTxt(text) {
  const map = {};
  if (!text) return map;
  const re = /([A-Za-z0-9\-:]+)\s*=\s*"([^"]*)"/g;
  let m;
  while ((m = re.exec(text)) !== null) {
    map[m[1]] = m[2];
  }
  return map;
}
function exifxmp_mapPix4D(meta, txt) {
  const x = meta && meta.xmp ? meta.xmp : {};
  const dj = x['drone-dji'] || x.drone || x['aux'] || {};
  const txtMap = txt || {};
  const getTxt = (k) => (txtMap[k] ?? txtMap['drone-dji:'+k] ?? null);
  const pick = (...vals) => {
    for (const v of vals) {
      if (v !== undefined && v !== null && v !== '') return v;
    }
    return null;
  };
  return {
    // Position and altitude
    lat: pick(
      meta.latitude, meta.GPSLatitude, meta.gpsLatitude,
      dj.GpsLatitude, getTxt('GpsLatitude'), getTxt('GPSLatitude'), getTxt('latitude')
    ),
    lon: pick(
      meta.longitude, meta.GPSLongitude, meta.gpsLongitude,
      dj.GpsLongitude, getTxt('GpsLongitude'), getTxt('GPSLongitude'), getTxt('longitude')
    ),
    absAlt: pick(meta.GPSAltitude, meta.gpsAltitude, dj.AbsoluteAltitude, x.AbsoluteAltitude, getTxt('AbsoluteAltitude')),
    relAlt: pick(dj.RelativeAltitude, dj.relativeAltitude, x.RelativeAltitude, getTxt('RelativeAltitude')),

    // Aircraft attitude and gimbal
    flightDir: pick(dj.FlightYawDegree, dj.flightDirection, x.FlightYawDegree, getTxt('FlightYawDegree')),
    flightRoll: pick(dj.FlightRollDegree, x.FlightRollDegree, getTxt('FlightRollDegree')),
    flightPitch: pick(dj.FlightPitchDegree, x.FlightPitchDegree, getTxt('FlightPitchDegree')),
    gRoll: pick(dj.GimbalRollDegree, dj.gimbalRoll, x.GimbalRollDegree, getTxt('GimbalRollDegree')),
    gPitch: pick(dj.GimbalPitchDegree, dj.gimbalPitch, x.GimbalPitchDegree, getTxt('GimbalPitchDegree')),
    gYaw: pick(dj.GimbalYawDegree, dj.gimbalYaw, x.GimbalYawDegree, getTxt('GimbalYawDegree')),

    // GNSS/RTK quality
    gnssPosAcc: pick(dj.gnssAccuracyPosition, x.GpsHAccuracy, getTxt('GpsHAccuracy')),
    gnssHAcc: pick(dj.gnssAccuracyHeight, x.GpsVAccuracy, getTxt('GpsVAccuracy')),
    gpsSats: pick(x.GpsNum, getTxt('GpsNum')),
    gpsSignal: pick(x.GpsSignalLevel, getTxt('GpsSignalLevel')),
    gpsStatus: pick(dj.GpsStatus, x.GpsStatus, getTxt('GpsStatus')),
    rtkFlag: pick(dj.RtkFlag, getTxt('RtkFlag')),
    rtkStdLon: pick(dj.RtkStdLon, parseFloat(getTxt('RtkStdLon'))),
    rtkStdLat: pick(dj.RtkStdLat, parseFloat(getTxt('RtkStdLat'))),
    rtkStdHgt: pick(dj.RtkStdHgt, parseFloat(getTxt('RtkStdHgt'))),

    // Kinematics
    speedX: pick(dj.FlightXSpeed, x.VelocityX, getTxt('FlightXSpeed'), getTxt('VelocityX')),
    speedY: pick(dj.FlightYSpeed, x.VelocityY, getTxt('FlightYSpeed'), getTxt('VelocityY')),
    speedZ: pick(dj.FlightZSpeed, x.VelocityZ, getTxt('FlightZSpeed'), getTxt('VelocityZ')),

    // Camera/exposure
    make: pick(meta.Make, meta.make, getTxt('Make')),
    model: pick(meta.Model, meta.model, getTxt('Model')),
    focal: pick(meta.FocalLength, meta.focalLength, getTxt('FocalLength')),
    iso: pick(meta.ISO, meta.ISOSpeedRatings, getTxt('ISO')),
    shutter: pick(meta.ExposureTime, getTxt('ExposureTime')),
    fnumber: pick(meta.FNumber, getTxt('FNumber')),
  };
}
function exifxmp_render(meta, txt) {
  const resultsDiv = document.getElementById('exifXmpResults');
  if (!resultsDiv) return;
  const m = exifxmp_mapPix4D(meta, txt);
  const fmt = (v, d=2, suf='') => (v!=null && !isNaN(v)) ? Number(v).toFixed(d)+suf : 'N/A';
  const fmtStr = (v) => (v!==undefined && v!==null && v!=='') ? String(v) : 'N/A';

  // Optional: render all available tags (from provided .txt, or flatten xmp)
  let allTagsHtml = '';
  const buildAllTags = () => {
    const rows = [];
    if (txt) {
      const keys = Object.keys(txt).sort();
      keys.forEach(k => rows.push(`<tr><td class="pr-2 py-0.5">${k}</td><td class="py-0.5">${fmtStr(txt[k])}</td></tr>`));
    } else if (meta && meta.xmp && typeof meta.xmp === 'object') {
      const flatten = (obj, pfx='') => {
        Object.entries(obj).forEach(([k,v])=>{
          const key = pfx ? `${pfx}:${k}` : k;
          if (v && typeof v === 'object' && !Array.isArray(v)) flatten(v, key);
          else rows.push(`<tr><td class="pr-2 py-0.5">${key}</td><td class="py-0.5">${fmtStr(v)}</td></tr>`);
        });
      };
      flatten(meta.xmp);
    }
    if (rows.length) {
      allTagsHtml = `
        <details class="mt-3">
          <summary class="cursor-pointer text-xs text-gray-600 dark:text-gray-300">Show all parsed XMP tags</summary>
          <div class="mt-2 max-h-56 overflow-auto border border-gray-200 dark:border-gray-700 rounded">
            <table class="w-full text-xs">
              <tbody>${rows.join('')}</tbody>
            </table>
          </div>
        </details>
      `;
    }
  };
  buildAllTags();

  resultsDiv.innerHTML = `
    <div class="grid grid-cols-2 gap-4 text-sm">
      <div><strong>GPS Coordinates:</strong> ${fmt(m.lat,8)}, ${fmt(m.lon,8)}</div>
      <div><strong>Absolute Altitude:</strong> ${fmt(m.absAlt,2,' m')}</div>
      <div><strong>Relative Altitude:</strong> ${fmt(m.relAlt,2,' m')}</div>

      <div><strong>Camera Make:</strong> ${fmtStr(m.make)}</div>
      <div><strong>Camera Model:</strong> ${fmtStr(m.model)}</div>
      <div><strong>Focal Length:</strong> ${fmt(m.focal,2,' mm')}</div>
      <div><strong>Exposure:</strong> ISO ${fmtStr(m.iso)} Â· ${fmtStr(m.shutter)} s Â· f/${fmtStr(m.fnumber)}</div>

      <div><strong>Flight Direction (Yaw):</strong> ${fmt(m.flightDir,2,'Â°')}</div>
      <div><strong>Flight Attitude (Roll/Pitch):</strong> ${fmt(m.flightRoll,2,'Â°')} / ${fmt(m.flightPitch,2,'Â°')}</div>

      <div><strong>Gimbal Angles (R/P/Y):</strong> ${fmt(m.gRoll,2,'Â°')}, ${fmt(m.gPitch,2,'Â°')}, ${fmt(m.gYaw,2,'Â°')}</div>

      <div><strong>GNSS Acc (H/V):</strong> ${fmt(m.gnssPosAcc,2,' m')} / ${fmt(m.gnssHAcc,2,' m')}</div>
      <div><strong>GNSS Sats / Signal:</strong> ${fmtStr(m.gpsSats)} / ${fmtStr(m.gpsSignal)}</div>

      <div><strong>Velocity (X/Y/Z):</strong> ${fmt(m.speedX,2,' m/s')}, ${fmt(m.speedY,2,' m/s')}, ${fmt(m.speedZ,2,' m/s')}</div>

      <div><strong>RTK Flag:</strong> ${fmtStr(m.rtkFlag)}</div>
      <div><strong>RTK Std (Lon/Lat/Hgt):</strong> ${fmt(m.rtkStdLon,3,' m')}, ${fmt(m.rtkStdLat,3,' m')}, ${fmt(m.rtkStdHgt,3,' m')}</div>
    </div>
    ${allTagsHtml}
  `;
}
function exifxmp_init(maxTries = 20) {
  const toolSelect = document.getElementById('toolSelect');
  const exifXmpPanel = document.getElementById('toolPanel');
  const exifXmpClose = document.getElementById('exifXmpClose');
  const exifXmpFileInput = document.getElementById('exifXmpFileInput');
  const openBtn = document.getElementById('openToolPanelBtn');

  // New display panel elements (may exist alongside EXIF panel)
  const displayPanel = document.getElementById('displayPanel');
  const displayClose = document.getElementById('displayClose');
  const displayFolderInput = document.getElementById('displayFolderInput');

  // Robust retry until all required elements are present
  if (!toolSelect || !exifXmpPanel || !exifXmpFileInput || !exifXmpClose || !openBtn || !displayPanel || !displayClose) {
    if (maxTries > 0) {
      console.warn('EXIF/XMP init: elements not found, retrying...', maxTries);
      return setTimeout(() => exifxmp_init(maxTries - 1), 150);
    }
    console.warn('EXIF/XMP init: elements not found after retries');
    return;
  }
  if (toolSelect.dataset.exifXmpInit === '1') return;
  toolSelect.dataset.exifXmpInit = '1';

  // Ensure panels overlay map reliably
  exifXmpPanel.style.zIndex = '2000';
  exifXmpPanel.style.pointerEvents = 'auto';
  displayPanel.style.zIndex = '2000';
  displayPanel.style.pointerEvents = 'auto';

  let currentOpen = null; // 'exif' | 'display' | null

  function showPanel(name) {
    if (name === 'exif') {
      exifXmpPanel.classList.remove('hidden'); exifXmpPanel.style.display = 'block';
      displayPanel.classList.add('hidden'); displayPanel.style.display = 'none';
      currentOpen = 'exif';
      try { exifXmpFileInput.focus(); } catch {}
    } else if (name === 'display') {
      displayPanel.classList.remove('hidden'); displayPanel.style.display = 'block';
      exifXmpPanel.classList.add('hidden'); exifXmpPanel.style.display = 'none';
      currentOpen = 'display';
      try { displayFolderInput && displayFolderInput.focus(); } catch {}
    }
  }
  function closeAllPanels() {
    exifXmpPanel.classList.add('hidden'); exifXmpPanel.style.display = 'none';
    displayPanel.classList.add('hidden'); displayPanel.style.display = 'none';
    currentOpen = null;
  }

  toolSelect.addEventListener('change', (e) => {
    console.log('toolSelect change ->', e.target.value);
    const v = e.target.value;
    if (v === 'exif-xmp-reader') {
      openBtn.classList.remove('hidden');
      showPanel('exif');
    } else if (v === 'display-drone-flight') {
      openBtn.classList.remove('hidden');
      showPanel('display');
    } else {
      openBtn.classList.add('hidden');
      closeAllPanels();
    }
  });

  openBtn.addEventListener('click', () => {
    // Toggle current visible panel or open the selected one
    if (!currentOpen) {
      const v = toolSelect.value;
      if (v === 'exif-xmp-reader') showPanel('exif');
      else if (v === 'display-drone-flight') showPanel('display');
    } else {
      closeAllPanels();
    }
  });

  exifXmpClose.addEventListener('click', () => {
    closeAllPanels();
    toolSelect.value = '';
    openBtn.classList.add('hidden');
  });
  displayClose.addEventListener('click', () => {
    closeAllPanels();
    toolSelect.value = '';
    openBtn.classList.add('hidden');
  });

  // Wire EXIF panel visible button to the hidden file input
  // (button #exifXmpSelectBtn triggers click on hidden #exifXmpFileInput)
  try {
    const selectBtn = document.getElementById('exifXmpSelectBtn');
    if (selectBtn && exifXmpFileInput) {
      selectBtn.addEventListener('click', () => exifXmpFileInput.click());
    }
  } catch (e) {
    console.warn('Failed to wire exif select button:', e);
  }

  // Auto-open panel if the tool is already selected at load
  if (toolSelect.value === 'exif-xmp-reader') {
    openBtn.classList.remove('hidden');
    showPanel('exif');
    console.log('EXIF/XMP panel auto-opened due to pre-selected value');
  } else if (toolSelect.value === 'display-drone-flight') {
    openBtn.classList.remove('hidden');
    showPanel('display');
    console.log('DISPLAY DRONE FLIGHT panel auto-opened due to pre-selected value');
  } else {
    openBtn.classList.add('hidden');
    closeAllPanels();
  }

  console.log('EXIF/XMP toolbox initialized (panel manager)');
}
if (document.readyState === 'complete' || document.readyState === 'interactive') {
  setTimeout(() => exifxmp_init(), 0);
} else {
  document.addEventListener('DOMContentLoaded', () => exifxmp_init());
  window.addEventListener('load', () => exifxmp_init());
}

// Helper: robustly extract embedded XMP packet from a JPEG ArrayBuffer by searching byte sequences
function extractXmpFromArrayBuffer(ab) {
  try {
    if (!ab || !ab.byteLength) return null;
    const bytes = new Uint8Array(ab);
    // ASCII bytes for "<x:xmpmeta" and "</x:xmpmeta>"
    const startSeq = new TextEncoder().encode('<x:xmpmeta');
    const endSeq = new TextEncoder().encode('</x:xmpmeta>');
    // helper to find sequence index
    function indexOfSeq(arr, seq, from=0) {
      for (let i = from; i <= arr.length - seq.length; i++) {
        let ok = true;
        for (let j = 0; j < seq.length; j++) {
          if (arr[i + j] !== seq[j]) { ok = false; break; }
        }
        if (ok) return i;
      }
      return -1;
    }
    const start = indexOfSeq(bytes, startSeq, 0);
    if (start === -1) return null;
    const end = indexOfSeq(bytes, endSeq, start);
    if (end === -1) return null;
    // include end tag length
    const slice = bytes.subarray(start, end + endSeq.length);
    // decode as UTF-8 â€” XMP is ASCII/UTF-8
    try {
      return new TextDecoder('utf-8', {fatal:false}).decode(slice);
    } catch(e) {
      // fallback to basic decoding
      let s = '';
      for (let i=0;i<slice.length;i++) s += String.fromCharCode(slice[i]);
      return s;
    }
  } catch (err) {
    console.warn('extractXmpFromArrayBuffer failed', err);
    return null;
  }
}
  exifXmpFileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    try {
      // First try exifr for structured EXIF/XMP
      const metadata = await exifr.parse(file, { xmp: true });
      exifxmp_lastMeta = metadata || {};

      // Then read raw bytes and extract embedded XMP packet (more reliable for DJI tags)
      let parsedDict = null;
      try {
        const ab = await file.arrayBuffer();
        const xmpText = extractXmpFromArrayBuffer(ab);
        if (xmpText) {
          try {
            const doc = new DOMParser().parseFromString(xmpText, 'application/xml');
            parsedDict = {};
            const elems = doc.getElementsByTagName('*');
            for (let i = 0; i < elems.length; i++) {
              const el = elems[i];
              for (let j = 0; j < el.attributes.length; j++) {
                const attr = el.attributes[j];
                parsedDict[attr.name] = attr.value;
                parsedDict[attr.localName] = attr.value;
                if (attr.prefix) parsedDict[`${attr.prefix}:${attr.localName}`] = attr.value;
              }
            }
          } catch (xmlErr) {
            console.warn('DOMParser failed for embedded XMP bytes, falling back to key/value parse', xmlErr);
            parsedDict = exifxmp_parseTxt(xmpText);
          }
        } else {
          // Fallback: decode bytes as text and search for XMP/RDF blocks
          const text = new TextDecoder().decode(ab);
          const sx = text.indexOf('<x:xmpmeta');
          const sr = text.indexOf('<rdf:RDF');
          let block = null;
          if (sx !== -1) {
            const ex = text.indexOf('</x:xmpmeta>', sx);
            block = ex !== -1 ? text.slice(sx, ex + '</x:xmpmeta>'.length) : text.slice(sx);
          } else if (sr !== -1) {
            const er = text.indexOf('</rdf:RDF>', sr);
            block = er !== -1 ? text.slice(sr, er + '</rdf:RDF>'.length) : text.slice(sr);
          }
          if (block) {
            try {
              const doc = new DOMParser().parseFromString(block, 'application/xml');
              parsedDict = {};
              const elems = doc.getElementsByTagName('*');
              for (let i = 0; i < elems.length; i++) {
                const el = elems[i];
                for (let j = 0; j < el.attributes.length; j++) {
                  const attr = el.attributes[j];
                  parsedDict[attr.name] = attr.value;
                  parsedDict[attr.localName] = attr.value;
                  if (attr.prefix) parsedDict[`${attr.prefix}:${attr.localName}`] = attr.value;
                }
              }
            } catch (xmlErr) {
              console.warn('DOMParser failed for block, falling back to key/value parse', xmlErr);
              parsedDict = exifxmp_parseTxt(block);
            }
          } else {
            parsedDict = exifxmp_parseTxt(text);
          }
        }
      } catch (readErr) {
        console.warn('ArrayBuffer/text extraction failed; falling back to exifr-only', readErr);
      }

      console.log('EXIF+XMP parsedDict keys:', Object.keys(parsedDict || {}).slice(0,40));
      if (metadata && metadata.xmp) console.log('EXIFR xmp keys:', Object.keys(metadata.xmp || {}).slice(0,40));

      // Render merged results (parsedDict takes precedence)
      exifxmp_render(metadata || {}, parsedDict || {});
    } catch (err) {
      console.error('Error reading metadata (exifr):', err);
      const resultsDiv = document.getElementById('exifXmpResults');
      if (resultsDiv) resultsDiv.innerHTML = `<div class="text-red-600">Error: ${err.message}</div>`;
    }
  });



<!-- Tools Side Panel (right) - EXIF+XMP READER (exclusive) -->
<aside id="toolPanel" class="fixed top-[56px] right-0 bottom-0 w-[420px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl hidden z-[2000]">
  <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
    <h3 class="text-base font-semibold text-gray-800 dark:text-gray-100">EXIF+XMP READER</h3>
    <button id="exifXmpClose" class="px-2 py-1 text-sm rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200">Close</button>
  </div>
  <div class="p-4 overflow-y-auto h-full">
    <!-- Hidden file input + visible action button per request -->
    <input type="file" id="exifXmpFileInput" accept="image/jpeg" class="hidden" />
    <button id="exifXmpSelectBtn" class="mb-2 w-full px-3 py-2 rounded bg-blue-600 text-white">Select JPG Image</button>
    <div class="text-xs text-gray-500 mb-2">Tip: Select a JPG image to read EXIF/XMP from the file.</div>
    <div id="exifXmpResults" class="space-y-4 text-sm"></div>
  </div>
</aside>

<!-- DISPLAY DRONE FLIGHT Panel + batched parser (separate tool panel) -->
<aside id="displayPanel" class="fixed top-[56px] right-0 bottom-0 w-[420px] bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-gray-700 shadow-xl hidden z-[2000]">
  <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
    <h3 class="text-base font-semibold text-gray-800 dark:text-gray-100">DISPLAY DRONE FLIGHT</h3>
    <button id="displayClose" class="px-2 py-1 text-sm rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200">Close</button>
  </div>
  <div class="p-4 overflow-y-auto h-full">
    <!-- Folder/multi-file selector (top-level JPGs only) -->
    <input type="file" id="displayFolderInput" accept="image/jpeg" class="mb-2 w-full" webkitdirectory directory multiple />
    <div class="text-xs text-gray-500 mb-2">
      Tip: Select a folder (or multiple files). Only top-level JPG/JPEG files in the selected folder are processed â€” subfolders are ignored.
    </div>

    <!-- Progress & skipped list -->
    <div id="displayFolderProgress" class="text-sm text-gray-600 mb-2" style="display:none">Processed 0 / 0</div>
    <div id="displaySkippedContainer" class="mb-2" style="display:none">
      <div class="text-xs text-red-600 mb-1">Skipped images (no GPS):</div>
      <div id="displaySkippedList" class="max-h-32 overflow-auto text-xs border border-gray-100 dark:border-gray-700 rounded p-2 bg-gray-50 dark:bg-gray-800"></div>
      <div class="mt-2">
        <button id="displaySkippedExport" class="px-2 py-1 text-xs rounded border">Export skipped list</button>
      </div>
    </div>

    <div id="displayToolNotes" class="text-xs text-gray-500">Parsed images will be immediately displayed on the map as blue markers.</div>
  </div>
</aside>

<script>
(function(){
  const folderInput = document.getElementById('displayFolderInput');
  const progressDiv = document.getElementById('displayFolderProgress');
  const skippedContainer = document.getElementById('displaySkippedContainer');
  const skippedListDiv = document.getElementById('displaySkippedList');
  const skippedExportBtn = document.getElementById('displaySkippedExport');

  if (!folderInput) {
    console.warn('Folder input not found (displayFolderInput)');
    return;
  }

  // Helper: sleep/yield to allow UI updates between batches
  const yieldOnce = () => new Promise(res => setTimeout(res, 0));

  // Default concurrency/batch settings (safe for GH Pages; avoids blocking)
  const CONCURRENCY = 12; // files processed concurrently per batch (increased per request)
  const MAX_IMPORT = 10000; // maximum number of images to import from a folder selection

  folderInput.addEventListener('change', async (e) => {
    const fileList = Array.from(e.target.files || []);
    if (fileList.length === 0) return;

    // Filter to JPEGs only and top-level files (no nested subfolders)
    let jpgs = fileList.filter(f => {
      const nameOk = /\.(jpe?g)$/i.test(f.name);
      // If webkitRelativePath exists, treat top-level as path segments length <= 2
      if (f.webkitRelativePath && f.webkitRelativePath.includes('/')) {
        const segs = f.webkitRelativePath.split('/');
        return nameOk && segs.length <= 2; // folderName/file.jpg OR file.jpg
      }
      return nameOk;
    }).sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric:true}));

    // Enforce a hard import limit to avoid excessive memory/CPU on static hosting
    if (jpgs.length > MAX_IMPORT) {
      alert(`Selected ${jpgs.length} images â€” importing first ${MAX_IMPORT} only.`);
      jpgs = jpgs.slice(0, MAX_IMPORT);
    }

    if (jpgs.length === 0) {
      progressDiv.style.display = 'none';
      skippedContainer.style.display = 'none';
      skippedListDiv.innerHTML = '';
      alert('No top-level JPG/JPEG files selected.');
      return;
    }

    // Prepare UI
    progressDiv.style.display = 'block';
    progressDiv.textContent = `Processed 0 / ${jpgs.length}`;
    skippedContainer.style.display = 'none';
    skippedListDiv.innerHTML = '';

    const skipped = [];
    let processed = 0;
    const parsedPoints = [];

    // Process in concurrent batches
    for (let i = 0; i < jpgs.length; i += CONCURRENCY) {
      const batch = jpgs.slice(i, i + CONCURRENCY);
      await Promise.all(batch.map(async (file) => {
        try {
          // Use exifr to get structured EXIF/XMP (existing library)
          let metadata = null;
          try { metadata = await exifr.parse(file, { xmp: true }); } catch (exifErr) { metadata = null; }

          // Try extract embedded XMP packet from bytes (more reliable for DJI)
          let parsedDict = null;
          try {
            const ab = await file.arrayBuffer();
            const xmpText = extractXmpFromArrayBuffer(ab);
            if (xmpText) {
              try {
                const doc = new DOMParser().parseFromString(xmpText, 'application/xml');
                parsedDict = {};
                const elems = doc.getElementsByTagName('*');
                for (let i = 0; i < elems.length; i++) {
                  const el = elems[i];
                  for (let j = 0; j < el.attributes.length; j++) {
                    const attr = el.attributes[j];
                    parsedDict[attr.name] = attr.value;
                    parsedDict[attr.localName] = attr.value;
                    if (attr.prefix) parsedDict[`${attr.prefix}:${attr.localName}`] = attr.value;
                  }
                }
              } catch (xmlErr) {
                parsedDict = exifxmp_parseTxt(xmpText);
              }
            }
          } catch (readErr) {
            // ignore and continue with metadata only
            parsedDict = parsedDict || {};
          }

          // Map to Pix4D-style object using existing helper
          const mapped = exifxmp_mapPix4D(metadata || {}, parsedDict || {});
          // Normalize numeric coordinates (strings may be present)
          const lat = mapped.lat !== undefined && mapped.lat !== null ? Number(mapped.lat) : NaN;
          const lon = mapped.lon !== undefined && mapped.lon !== null ? Number(mapped.lon) : NaN;
          const absAlt = mapped.absAlt !== undefined ? Number(mapped.absAlt) : null;
          const relAlt = mapped.relAlt !== undefined ? Number(mapped.relAlt) : null;

          if (!isFinite(lat) || !isFinite(lon)) {
            skipped.push({ name: file.name, reason: 'no-gps' });
            return;
          }

          // Create marker on map (reuse layerPhotos + allPhotoPoints)
          try {
            const marker = L.circleMarker([lat, lon], { radius: 3, color: 'blue' }).addTo(layerPhotos);
            const point = {
              lat: lat,
              lng: lon,
              absAlt: isFinite(absAlt) ? absAlt : null,
              relAlt: isFinite(relAlt) ? relAlt : null,
              filename: file.name,
              marker: marker,
              // no strip/point indices for imported folder images
              stripIndex: null,
              pointIndex: parsedPoints.length
            };
            parsedPoints.push(point);
            allPhotoPoints.push(point);
          } catch (mapErr) {
            console.warn('Failed to add marker for', file.name, mapErr);
            skipped.push({ name: file.name, reason: 'map-error' });
          }
        } catch (err) {
          console.error('Error parsing file', file.name, err);
          skipped.push({ name: file.name, reason: 'parse-error' });
        } finally {
          processed++;
          progressDiv.textContent = `Processed ${processed} / ${jpgs.length}`;
        }
      }));
      // yield to UI between batches
      await yieldOnce();
    }

    // Update summary count if summary exists
    try {
      summaryStats.numPhotos = allPhotoPoints.length;
      if (summaryTable) {
        summaryTable.innerHTML = `
          <tr><td>${t('summaryArea')}</td><td>${formatNumberDE(parseFloat(summaryStats.areaHa))} ha</td></tr>
          <tr><td>${t('summaryStrips')}</td><td>${summaryStats.numStrips}</td></tr>
          <tr><td>${t('summaryPhotos')}</td><td>${summaryStats.numPhotos}</td></tr>
          <tr><td>${t('summaryLength')}</td><td>${formatNumberDE(parseFloat(summaryStats.totalLengthKm))} km</td></tr>
          <tr><td>${t('summaryTime')}</td><td>${summaryStats.estTimeMin} min</td></tr>
        `;
      }
    } catch (e) {
      console.warn('Failed updating summary:', e);
    }

    // Show skipped list if any
    if (skipped.length > 0) {
      skippedContainer.style.display = 'block';
      skippedListDiv.innerHTML = skipped.map(s => `<div>${s.name} â€” ${s.reason}</div>`).join('');
    } else {
      skippedContainer.style.display = 'none';
      skippedListDiv.innerHTML = '';
    }

    // Finalize progress UI
    progressDiv.textContent = `Processed ${processed} / ${jpgs.length} â€” added ${parsedPoints.length} points`;
    // ensure map view fits added markers if any
    try {
      if (parsedPoints.length > 0) {
        const group = L.featureGroup(parsedPoints.map(p => p.marker));
        map.fitBounds(group.getBounds().pad(0.1));
      }
    } catch (err) {
      console.warn('fitBounds failed', err);
    }
  });

  // Export skipped list as text file
  if (skippedExportBtn) {
    skippedExportBtn.addEventListener('click', () => {
      const items = Array.from(skippedListDiv.querySelectorAll('div')).map(d => d.textContent || d.innerText);
      if (items.length === 0) {
        alert('No skipped images to export.');
        return;
      }
      const blob = new Blob([items.join('\\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'skipped-images.txt';
      a.click();
      URL.revokeObjectURL(url);
    });
  }
})();
</script>
<script>
  // EXIF/XMP & DISPLAY panels: optional ESC to close active panel
  (function(){
    function initEscClose(maxTries=20){
      const panel = document.getElementById('toolPanel');
      const display = document.getElementById('displayPanel');
      const closeBtn = document.getElementById('exifXmpClose');
      const displayClose = document.getElementById('displayClose');
      const toolSelect = document.getElementById('toolSelect');
      if (!panel || !closeBtn || !toolSelect || !display || !displayClose) {
        if (maxTries>0) return setTimeout(()=>initEscClose(maxTries-1),150);
        return;
      }
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Escape') {
          if (panel && !panel.classList.contains('hidden')) {
            panel.classList.add('hidden');
            toolSelect.value = '';
          }
          if (display && !display.classList.contains('hidden')) {
            display.classList.add('hidden');
            toolSelect.value = '';
          }
        }
      });
    }
    if (document.readyState==='complete'||document.readyState==='interactive') setTimeout(()=>initEscClose(),0);
    else { document.addEventListener('DOMContentLoaded',()=>initEscClose()); window.addEventListener('load',()=>initEscClose()); }
  })();
</script>
</body>
</html>

